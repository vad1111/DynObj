using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Динамические.действия;

namespace Динамические
{

    // Действие это набор инструкций для некоторой активности
    // например взять число по адресу, прибавить к нему 1, поместить результат по адресу (или в переменную) (переменная это именованный адрес+ название типа)
    // эти инструкции не содержат распознания ситуации, реакции на ошибки, сложные связи
    public class ДействиеАктивность : Активность
    {
        //public List<object> Параметры;
        public object Выполнить() //это аналог получить() активности
        {
            return null;
        }


        //public override object СовершитьПреобразование()
        //{
        //    //var параметр1 = (int) СписокВходящих[1].ДайЗначение();
        //    //var параметр2 = (int) СписокВходящих[2].ДайЗначение();
        //    //var сумма= параметр1 + параметр2;
        //    return сумма;
        //}
    }

    public class ПространствоИмен2
    {
        public ПространствоИмен2 Родитель;

        //локальный словарь
        public Dictionary<string, (Type,object)> СловарьВнутреннихПеременных;
        
    }

    // План действий, рецепт - это не само действие. Действие это когда его выполняет процессор
    // Процессор содержит Хранилище переменных, не каждое действие требует этих перемеенных
    // Перейти к плану действию номер это прямая выполняемая инструкция (команда)
    // Большая часть это скрытые функции (типа аппаратные)
    public class План : РАМОбъект
    {
        public string Метка; //Метка
        public ГруппаОбъектов Описание;
        public Процессор ТипПроцессора;  // Реальный(native),

        public Dictionary<string, object> СловарьВнутреннихПеременных;
        public List<string> СписокИменПеременных;// можно потом использовать просто номер перемеенной
        public List<string> СписокТиповПеременных; // можно заменить на адреса типов
        public List<object> СписокЗначенийПеременных; 
        public Dictionary<string, ТипизированноеЗначение> СловарьТипизированныхПеременных;
        public List<ТипизированнаяПеременная> СписокТипизированныхПеременных; 
        
        public План ВышестоящийПлан; // доступ к вышестоящему действию

        public virtual object Выполнить()
        {
            return null;
        }
        public virtual object Выполнить( object[] аргументы)
        {
            return null;
        }
        public virtual object Выполнить( План вызывающееДействие)
        {
            return null;
        }
        public virtual int ПроверитьНаДоступность( Словарь словарьВнутреннихДействийПроцессора)
        {
            return 0; // это пустое действие количество незвестных инструкций
        }

        public void СоздатьСписокПеременных()
        {
            СписокЗначенийПеременных= new List<object>(); СписокИменПеременных= new List<string>(); СписокТиповПеременных=new List<string>();
        }
        public int НомерПеременной(string ИмяПеременной)
        {
            for (int i = 0; i < СписокИменПеременных.Count; i++)
            {
                if (СписокИменПеременных[i] == ИмяПеременной) return i;
            }
            return -1;
        }
        public object ЗначениеПеременной(string ИмяПеременной)
        {
            for (int i = 0; i < СписокИменПеременных.Count; i++)
            {
                if (СписокИменПеременных[i] == ИмяПеременной) return СписокЗначенийПеременных[i];
            }
            return null;
        }

        public object ДобавитьПеременную(string Имя, string Тип, object Значение)
        {
            var номер = НомерПеременной(Имя);
            if (номер == -1) return "ошибка: имя переменной занято";
            СписокИменПеременных.Add(Имя);
            СписокТиповПеременных.Add(Тип);
            СписокЗначенийПеременных.Add(Значение);
            return "готово";
        }
       
    }

    // это действие рализует любую не static команду С# 
    public class АппаратноеДействие : План
    {
        public MethodInfo Метод;
        public object Окружение;    // метод выполняется в данном окружении. Метод принадлежит конкретному окружению = классу

        public bool ПроверитьОкружение()
        {
            if (Метод.DeclaringType == Окружение.GetType()) return true; // еще надо проверить
            if( Окружение.GetType().IsSubclassOf(Метод.DeclaringType)  ) return true;
            return false;
        }
        public override object Выполнить(План вызывающееДействие)
        {
            if (!ПроверитьОкружение()) return null; // еще надо проверить

            var результат = Метод.Invoke(Окружение, СписокЗначенийПеременных.ToArray());
            return null;
        }
    }

    public class НечеткаяПоследовательность: План // тут список действий выполняется непоследовательно, вариант ищется действие с наибольшим весом
    {
        public List<План> СписокТекущихДействий; //это дествие совершается полюбому
       
        public List<План> СписокСледующихДействий; //это переходы к следующему действию
        public List<int> ВесДействия; 
        // сначала выполняется действие с наибольшим весом, потом все с меньшим и меньшим
        // вариант с плохой памятью, выбирается случайное действие
        // принудительно плохая память, первое дествие = пропускается наибольший вес, берется второй по порядку
        // принудительно плохая память - требование разнообразия, конкуренции, мутация 
        // ДРУГОй вариант неточности, это пропуск действий если действие завершилось неудачей (неудачи могут быть разными, несовпадение типа, неопределенность переменной, неопределенность метода, выход за границы (переполнение), несоответствие ожиданиям
        // псоледовательность на самом деле не последовательность, следущее действие точно не известно
        // возможны переходы через шаг, пропуск- пустое действие - это один из вариантов 
        // програмирование это вставки новых действий в существующую последовательность
        // если новое вставленное действие непроверенно, то создается пара действий (новое + пропуск) с одними и теми же исходящими
        // так например это добавление типов к переменной 
        //(добавление типов затрагивает целую кучу методов, которые должны быть изменены синхронно, дай значение перемееной не затрагивается, появляется "дай тип переменной"
        // возможно добавление целой цепочки действий+ пропуск
            // это похоже на именование цепочки (блока кода), метод без параметров
        // ускорение действий это удаление , усечение (например можно заменить вызов функции телом функции, увеличиваются расходы памяти (может появиться несколько последовательностей действий), экономия памяти за счет удаления справочника переменных функции, ускорение за счет удаления действий копирования параметров, создания новых переменных
        // могут сохраняться оба пути , но конечный пункт у них одинаковый, сохраняется четкое описание,
        // можно выбрасывать часть внутренних проверок, если заранее известно, попадание в диапазон, это накладывает ограничения на входящие параметры
        // как правило создание нового кода сявзано с использованием нового более общего шаблона, к существующей конкретной ситуации, цели улучшения: ускорение работы, экономия ресурсов, улучшение совместимости, 
        // анализ кода обратная задача: разбить код на кусочки, присвоить им имя понять что он делает, найти повторы


        public План ПредыдущееДействие; //  откуда пришел поток
        public List<План> СписокВозможныхПриходов; // приходы могут быть от разных действий = ВходящиеАктивности

    }

    public class КармическиеДействия : План
    {
        public Dictionary<(object,object), План> КармическиеСледы; 

        public object ТекущееСобытие;
        public object ТекущееСостояние;
        public object ЦельТекущая;

        public bool работаем;

        public void Восприятие()
        {
            while (работаем)
            {
                var реакция = КармическиеСледы[(ТекущееСобытие,ТекущееСостояние)];
                ТекущееСобытие = null;
                if (реакция == null) continue; // нет реакции игнор
                dynamic   рез= реакция.Выполнить(this); // шаг вперед, окружение изменилось -предмет стал ближе(ццель)
                // позиция изменилась- хорошо, позиция предмета изменилась, растояние до предмета уменьшилось- хорошо
                // увеличилось плохо, увеличить скорость до макимума,
                // если скорость уже на максимуме, сделать еще н попыток, если рез тоже плохо, остановиться
                if(рез.ИзменениеОкруженияСовпадаетСОжиданием())

                ТекущееСостояние = рез.НовоеСостояние;
            }

        }

    }

    // это основное Действие ТЕЛО ФУНКЦИИ ( у него правда почему то есть "Параметры" и отдельно "Список Внутренних переменных"
    // параметры это для функций, список внутренних переменных 
    public class ПоследовательностьДействий: План //это блок кода - не функция или функция без параметров и возвращаемого результата
    {
        public List<План> СписокДействий;
        

        public override object Выполнить(План вызывающееДействие)
        {
            ВышестоящийПлан = вызывающееДействие;// для доступа к вышележащим переменным
            СоздатьСписокПеременных();


            for (var индекс = 0; индекс < СписокДействий.Count; )
            {
                var действие = СписокДействий[индекс];
                if (действие is Прервать)
                {
                    return "прервать";
                }

                
                if (действие is ПерейтиК)
                {
                    индекс = СписокДействий.FindIndex(план => план.Метка == ((ПерейтиК) действие).МеткаКуда);
                }

                try
                {
                    действие.Выполнить(this);
                }
                catch (Exception exception)
                {
                    return "ошибка в " + действие + exception;
                }

                индекс++;
            }

            return "готово";
        }
    }

    internal class ПерейтиК : План
    {
        public string МеткаКуда;
    }

    // Запомнить план действий
    public class ОпределениеФункции : План //аналогично определению переменной, регистрация функции в некоторм окружении -это уже функция в виде дерева- 
    {
        // это шаблон команды, описание , можно расширять, имя результата
        public string ИмяФункции; // можно задать и список имен (имя1,имя2, имя3) все они будут ссылаться на один этот объект, можно 
        public List<string> Параметры; // это можно не указывать т.к. переменные это строки в теле они просто используются, нужно для вызова функции с неименованными параметрами
        public string ТипРезультата; //тоже может быть список типов


        public List<План> ТелоФункции; // в теле функции не нужно определять переменные с именем параметров, будет ошибка,т.к. при вызове она уже будет создана
       
        public override object Выполнить(План вызывающееДействие)
        {
            // определение функции в текущем контексте, можно выбрать другой контекст
            вызывающееДействие.ДобавитьПеременную(ИмяФункции,"функция", this); //вместо "функция" можно добавить "поле" "переменная" получиться класс
            return "готово";
        }
    }

    public class ВызватьФункцию : План
    {
        public string ИмяФункции;
        public Dictionary<string, РАМОбъект> СписокИменованныхПараметров; // если указывать параметры в виде списка (неименованного), то потребуется Список Параметров из Определения функции
        public object Результат;

        public override object Выполнить(План вызывающееДействие)
        {
            // найти определение функции в полученном окружении 
            // здесь только 
           var определениеФункции= (ОпределениеФункции) вызывающееДействие.ЗначениеПеременной(ИмяФункции);
            //создать контекст
            //СловарьВнутреннихПеременных = new Dictionary<string, object>();
            СоздатьСписокПеременных();

            // присвоить значение переданных параметров в текущий контекст
            foreach (var параметр in СписокИменованныхПараметров) 
            {
                СловарьВнутреннихПеременных.Add(параметр.Key, параметр.Value); //значение параметра может быть действие = значение другой переменной или адрес этой переменной 
                    // ПолучитьЗначениеПеременной{переменая=Имя}результат будет либо адрес либо примитив, примитив надо полностью копировать
                    //ПолучитьАдресПеременной(переменная=Имя), в функции появиться дубль внешней переменной , примитив тоже храниться по адресу в некоторой группе 
            }
            // запустить список Действий, используется один список действий из определения, но с разным контекстом
            foreach (var действие in определениеФункции.ТелоФункции)
            {
                if (действие is ВернутьРезультат)
                {
                    Результат = действие.Выполнить(this); 
                    break;
                } 
                действие.Выполнить(this);
            }
            
            //вернуть результат

            return Результат;
        }
    }

    public class Прервать: План //команды управления потоком выполнения
    { }
    public class Продолжить : План
    { }

    public class ВернутьРезультат : План
    {
        public РАМОбъект ВозращаемыйРезультат; // может быть и просто значение
        public override object Выполнить(План вызывающееДействие)
        {
            if(ВозращаемыйРезультат is План)
            return ((План) ВозращаемыйРезультат).Выполнить(вызывающееДействие); 
            return ВозращаемыйРезультат;
        }
    }

    public class СоздатьПеременную : План //не типизированную переменную тип object
    {
        public string ИмяПеременной;
        public object Значение; //это может быть и действие

        public override object Выполнить(План вызывающееДействие)
        {
            вызывающееДействие.СловарьВнутреннихПеременных.Add(ИмяПеременной,Значение);
            return "готово";
        }
    }
    public class ДайЗначениеПеременной : План //не типизированную переменную тип object
    {
        public string ИмяПеременной;
        public ДайЗначениеПеременной(string имя)
        {
            ИмяПеременной = имя;
        }

        public override object Выполнить(План вызывающееДействие)
        {
            // нужен рекурсивный поиск переменной в вышележащих 
            return вызывающееДействие.СловарьВнутреннихПеременных[ИмяПеременной];
        }
    }

    public class ПрисвоитьЗначениеПеременной : План
    {
        public string ИмяПеременной;
        public РАМОбъект Значение;
        public override object Выполнить(План вызывающееДействие)
        {
            // если такой переменной нет вернуть ошибку
            вызывающееДействие.СловарьВнутреннихПеременных[ИмяПеременной]=Значение;
            return "готово";
        }
    }

    public class Условие : План
    {
        public override object Выполнить(План вызывающееДействие)
        {
            return true;
        }
    }
    public class Цикл : План //while
    {
        public Условие УсловиеВыхода;
        public ПоследовательностьДействий ТелоЦикла;
        public override object Выполнить(План вызывающееДействие)
        {
            bool значениеУсловия;

проверкаУсловия: значениеУсловия = (bool) УсловиеВыхода.Выполнить(this);

            if (значениеУсловия == true)
            {
                var команда =(string) ТелоЦикла.Выполнить(this);
                if (команда == "готово") goto проверкаУсловия;
                if (команда == "продолжить") goto проверкаУсловия;
                if (команда == "прервать") return "готово"; //выход из цикла = break
            }
            
            return "готово";
        }
    }

    public class ЦиклСИндексом : План // for
    {
        public План СозданиеИндекса;
        public Условие УсловиеВыхода;
        public План ИзменеениеИндекса;
        public План ТелоЦикла; 
        public override object Выполнить(План вызывающееДействие)
        {
            СозданиеИндекса.Выполнить(this);
 
            while ( (bool) УсловиеВыхода.Выполнить(this))
            {
                ТелоЦикла.Выполнить(this);
                ИзменеениеИндекса.Выполнить(this);
            }
            return "готово";
        }
    }

    public class ПрисвоитьПеременную : План
    {
        public string ИмяПеременной;
        public Type Тип;
        public object Значение;

        public override object Выполнить(План вызывающееДействие)
        {
            if (Значение.GetType() == Тип)
            {
                // проверить не занятость имени переменной

                вызывающееДействие.СловарьВнутреннихПеременных.Add(ИмяПеременной, Значение);
                return "готово";
            }

            return "ошибка типа";
        }
    }



    public class Сложение : План
    {
        //Описание = команда: сложить  , имя параметра :слогаемое + номер параметра, тип параметра : число целое, значение параметра ХХХ, имя результата : сумма, тип результата -целое , имя действия : сложение
        // относиться к группе : действие или команда 
        // формат команды сложить слогаемое 1 и слогаемое 2
        // возможно лучше 

        public РАМОбъект слогаемое1;
        public РАМОбъект слогаемое2;
        public object РезультатДействия;



        public void ИзменитьПараметры (АдресВХранилище параметры)
        {
            //Параметры = параметры;
        }

        public static void Выполнить(ЦелоеЧисло слагаемое1, ЦелоеЧисло слагаемое2, ЦелоеЧисло результат)
        {
            результат.Значение = слагаемое1.Значение + слагаемое2.Значение;
        }

        public override object Выполнить(План вызывающееДействие)
        {
            ЦелоеЧисло[] слогаемое = new ЦелоеЧисло[2]; //это внутренние переменные

            

            слогаемое[0]  =  ПреобразоватьСлогаемое(вызывающееДействие, слогаемое1 );
            слогаемое[1]  =  ПреобразоватьСлогаемое(вызывающееДействие, слогаемое2); 
           

            РезультатДействия= new ЦелоеЧисло(){Значение = слогаемое[0].Значение + слогаемое[1].Значение} ;

            return РезультатДействия;
        }
        //этот метод лучше убрать из функции преобразовать в список действий т.к. их всего 2 вызова 
        private ЦелоеЧисло ПреобразоватьСлогаемое(План вызывающееДействие, РАМОбъект параметр)
        {
            if (параметр is План)
            {
                return (ЦелоеЧисло) ((План) слогаемое1).Выполнить(this);
            }
            else if (слогаемое1 is СтрокаЮникода) // это должно быть действие ПолучитьЗначениеПеременной
            {
                return (ЦелоеЧисло) вызывающееДействие.СловарьВнутреннихПеременных[((СтрокаЮникода) параметр).Значение];
            }
            else
            {
                return  (ЦелоеЧисло) параметр;
            }
        }
    }

    public class Значение : РАМОбъект
    {
        private АдресВХранилище АВХ;

        public object ДайЗначение()
        {
            return АВХ.АдресВКучеПамяти();
        }



    }
}
