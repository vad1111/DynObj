using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Динамические.Примитивы;

namespace Динамические
{
    public  class Хранилище
    {
        public static Dictionary<Type, byte> кодыТипов = new Dictionary<Type, byte>();
        public static List<Type> Типы = new List<Type>(){typeof(Пустота), typeof(СтрокаЮникода),typeof(ЦелоеЧисло), typeof(АдресВХранилище), typeof(СписокБайт),typeof(ГруппаОбъектов), 
             typeof(АдресВГруппе),typeof(СловарьПлохой),typeof(Символ),typeof(ГруппаТипизированная),typeof(ГруппаАдресовИзСловаря)};

        static Хранилище()
        {
            ПересчитатьКодыТипов();
        }

        public static void ПересчитатьКодыТипов()
        {
            кодыТипов = new Dictionary<Type, byte>();
            for (byte i = 0; i < Типы.Count; i++)
            {
                кодыТипов[Типы[i]] = i;
            }
        }

        private static byte длинаАдреса = 4; // длина в байтах
        
        public static List<РАМОбъект> Память = new List<РАМОбъект>();
        //размер памяти 
        public static string ИмяФайла = "Хранилище.ии";
        public static BinaryWriter Писатель;
        public static BinaryReader Читатель;
        private static int длинаФайла;
        public BinaryWriter ПисательУдаленные; //если каждый раз создается новый файл, то не нужен
        public BinaryReader ЧитательУдаленные;

        public static List<int> ИндексВпамяти; //при замене группы адрес объекта в Памяти не меняется, но меняется адрес в Файле
        public static BinaryWriter ПисательИндекса; //файл диспетчера удобен, чтобы не открывать все объекты, сами объекты могут в память даже  не загружаться это индексный файл
        public static BinaryReader ЧитательИндекса;
        public static void Сохранить()
        {
            Stream поток = new FileStream(ИмяФайла,FileMode.Create);
            Писатель = new BinaryWriter(поток);
            Писатель.Write("Хранилище");// запись имени объека
            Писатель.Write(длинаАдреса); //запись длины адреса
            // шаблон сохранения - код примитива , длина примитива (вычисляяется из кода примитива), байты примитива
            //шаблон сохранения - длина примитива, (код примитива), байты примитива
            // диспетчер может сохранять только адреса примитивов, а точнее первый уровень дерева, второй уровень это список других адресов и т.д.

            Stream потокИндекс = new FileStream(ИмяФайла+".индекс", FileMode.Create);

            ПисательИндекса = new BinaryWriter(потокИндекс);

            
            foreach (var примитивИлиАдрес in Память)
            {
                //сохранить индекс
                var текущаяПозиция = (int)Писатель.BaseStream.Position; //индекс записывается как int
                ПисательИндекса.Write(текущаяПозиция); //
                //позиция +=  примитивИлиАдрес.Длина;

                //сохранить объект
                var кодТипа =кодыТипов[примитивИлиАдрес.GetType()] ;
                Писатель.Write(кодТипа);
                примитивИлиАдрес.СохранисьВ(Писатель);
                
            }
            Писатель.Close();
            ПисательИндекса.Close();


        }

        //востанавливается только индекс, память не восстанавливается 
       

        public static void Восстановить(string имяФайла)
        {
            Stream поток = new FileStream(имяФайла, FileMode.Open);
            Читатель = new BinaryReader(поток);

            Закрыть(); // запустить закрытие всех активностей
            Память = new List<РАМОбъект>(); //обнулить память или создать новую при первом запуске
            GC.Collect();

            //ВосстановитьПамять();
            ВосстановитьИндекс(имяФайла);
            ВосстановитьПамятьПоИндексу();
            Читатель.Close(); Читатель = null;

        }

        public static void ВосстановитьИндекс(string имяФайла)
        {
            Stream поток = new FileStream(имяФайла+".индекс", FileMode.Open);
            ЧитательИндекса = new BinaryReader(поток);
            ИндексВпамяти= new List<int>();

            while (ЧитательИндекса.BaseStream.Length > ЧитательИндекса.BaseStream.Position)
            {
                var адресОбъектаВФайле = ЧитательИндекса.ReadInt32();
                ИндексВпамяти.Add(адресОбъектаВФайле);
            }
            ЧитательИндекса.Close();
            // поток не закрывается для дальнейших операций 
        }
        public static void ВосстановитьПамятьПоИндексу()
        {
            Читатель.ReadString();//=хранилище
            длинаАдреса = Читатель.ReadByte(); //длинаАдреса

            var активности = new List<Активность>(); //запускаемые объекты 
            for (int и = 0; и < ИндексВпамяти.Count; и++)
            {
                Читатель.BaseStream.Position = ИндексВпамяти[и];

                var номерТипа = Читатель.ReadByte();
                var тип = Типы[номерТипа];
                var k = тип.GetConstructor(Type.EmptyTypes);
                РАМОбъект примитив = (РАМОбъект)k.Invoke(null);
                примитив.Восстановить(Читатель);
                примитив.СобственныйАдресПримитива = new АдресВХранилище() { НомерВХранилище = и };
                //примитив.НомерВФайле = ИндексВпамяти[и]; //этот номер доступен по Индексу Хранилища 
                Память.Add(примитив);
                if (примитив is Активность) активности.Add((Активность)примитив);
            }
            foreach (var активность in активности)
            {
                try
                {
                    активность.Запуск();
                }
                catch (Exception)
                {
                }
            }

        }
        public static  void ВосстановитьПамять()
        {
            Читатель.ReadString();//=хранилище
            длинаАдреса = Читатель.ReadByte(); //длинаАдреса

            var активности = new List<Активность>(); //запускаемые объекты 

            while (Читатель.BaseStream.Length > Читатель.BaseStream.Position)
            {
                var номерТипа = Читатель.ReadByte();
                var тип = Типы[номерТипа];
                //var p = new object[0];
                var k = тип.GetConstructor(Type.EmptyTypes);
                РАМОбъект примитив = (РАМОбъект) k.Invoke(null);
                примитив.Восстановить(Читатель);
                    //.InvokeMember("Восстановить",BindingFlags.InvokeMethod, null,null,new []{Читатель});
                примитив.СобственныйАдресПримитива = new АдресВХранилище() {НомерВХранилище = Память.Count};
                Память.Add(примитив);
                if(примитив is Активность) активности.Add((Активность) примитив);

                
            }
            // цикл запуска активностей
            foreach (var активность in активности)
            {
                try
                {
                    активность.Запуск();
                }
                catch (Exception)
                {
                }
            }
        }

        public static void Закрыть() //завершить активности
        {
            foreach (var примитивИлиАдрес in Память)
            {
                var активность = примитивИлиАдрес as Активность;
                if(активность != null) активность.Закрыть();
            }
        }

        public void ДобавитьИСохранить( РАМОбъект примитивИлиАдрес ) // в конец
        {
            
            Память.Add(примитивИлиАдрес);

            Писатель.Seek(0, SeekOrigin.End);

            var кодТипа = кодыТипов[примитивИлиАдрес.GetType()];
            Писатель.Write(кодТипа);
            примитивИлиАдрес.СохранисьВ(Писатель);

            длинаФайла = (int) Писатель.BaseStream.Position; // = + длинаАдреса + длина списка

        }

        public static АдресВХранилище Добавить(РАМОбъект объект)
        {
            var номер = Память.Count;
            объект.СобственныйАдресПримитива = new АдресВХранилище() { НомерВХранилище = номер };
            Память.Add(объект);
            return (АдресВХранилище) объект.СобственныйАдресПримитива;
        }
    }
}
