using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Динамические
{
    public class ДисковоеХранилище : Группа
    {
        private  byte длинаАдреса = 4; // длина в байтах
        public  string ИмяФайла = "";
        public int СчетчикОбъетов;
        private byte адресСчетчика;
        private BinaryWriter Писатель;
        private BinaryReader Читатель;
        private  int длинаФайла;
        private BinaryWriter ПисательУдаленные; //если каждый раз создается новый файл, то не нужен
        private BinaryReader ЧитательУдаленные;

        public List<int> ИндексВпамяти; //при замене группы адрес объекта в Памяти не меняется, но меняется адрес в Файле
        public  BinaryWriter ПисательИндекса; //файл диспетчера удобен, чтобы не открывать все объекты, сами объекты могут в память даже  не загружаться это индексный файл
        public  BinaryReader ЧитательИндекса;

        public void Создать()
        {
           var поток= File.Create(ИмяФайла);
            Читатель = new BinaryReader(поток);
            Писатель = new BinaryWriter(поток);

            Писатель.Write("Дисковое Хранилище");
            Писатель.Write(длинаАдреса);
            адресСчетчика = (byte)Читатель.BaseStream.Position;
            Писатель.Write(СчетчикОбъетов);
            // индекс
            var потокИндекс = File.Create(ИмяФайла+".индекс");
            ПисательИндекса= new BinaryWriter(потокИндекс);
            ЧитательИндекса= new BinaryReader(потокИндекс);

        }
        public void Открыть() // можно запихать в конструктор
        {
            try
            {
                if (File.Exists(ИмяФайла))
                {
                    Stream поток = new FileStream(ИмяФайла, FileMode.Open, FileAccess.ReadWrite);
                    Читатель = new BinaryReader(поток);
                    Писатель = new BinaryWriter(поток);

                    Читатель.ReadString();//=хранилище
                    длинаАдреса = Читатель.ReadByte(); //длинаАдреса
                    адресСчетчика = (byte) Читатель.BaseStream.Position;
                    СчетчикОбъетов = Читатель.ReadInt32();

                    var потокИндекс = new FileStream(ИмяФайла + ".индекс", FileMode.Open, FileAccess.ReadWrite);
                    ПисательИндекса = new BinaryWriter(потокИндекс);
                    ЧитательИндекса = new BinaryReader(потокИндекс);
                }
                else
                {
                    Создать();
                }
                
            }
            catch (Exception)
            {

                throw;
            }

        }
        public override void СохранисьВ(BinaryWriter писатель)// это сохранение в центральном хранилище
        {
            писатель.Write(ИмяФайла);
        }
        public override РАМОбъект Восстановить(BinaryReader читатель)
        {
            ИмяФайла = читатель.ReadString();
            Открыть();
            return this;
        }

        /// <summary>
        /// зависит ведется счетчик объектов или нет (-1 - количество не известно
        /// Первоначально из просмортщика может видется только количество объектов, дальше может запроситься первые несколько чтобы посмтреть, дальше листание, в память загружаются только видимые
        /// </summary>
        /// <returns></returns>
        public int КоличествоОбъектов() // 
        {
            return СчетчикОбъетов;
        }

        public override string ToString()
        {
            return "Дисковое Хранилище "+ ИмяФайла+ " ("+СчетчикОбъетов+ " объектов)";
        }

        public void СоздатьКопиюОбъектВПрострастве(Адрес адрес, ГруппаОбъектов Память) //временное сохранение в памяти объекта
        {
            var объект = СоздатьКопиюОбъект(адрес);
            Память.Добавить(объект); // можно сохранить еще в хранилище это сохраняемый объект, а не временный, Память нужно в конце очищать или заводить отдельную группу с путым сохранением
        }

        public РАМОбъект СоздатьКопиюОбъект( Адрес адрес) //читает только первый уровень, не лезет разбирать адреса
        {
            var фАдрес = адрес as АдресВФайле;
            if (фАдрес == null) return Пустота.Статик;

            Читатель.BaseStream.Position = фАдрес.НомерБайтаВФайле; //перместить указатель на адрес объекта
            var  прим = РАМОбъект.Создать(Читатель.BaseStream);
            
            return прим;
        }

        // создать ссылку , прокси объекта для группы с индеском ничего не знает о адресе в основном файле. Чтобы прочитать объект, надо в индесном файле узнать реальный адрес
            // надо создать ДисковоеХранилище где АдресОбъекта это не АдресВФайле, а АдресВИндексе. Адресв Файле должен быть скрыт
        // прокси с Адресом в файле может быть не верным, кто-то может его изменить, или удалить.
        // группы в индесным файлом должны иметь ссылки не на адрес в основном файле а номер в индексе
        // примитивы с неизменной длинной нет смысла переносить. А группы могут переноситься в конец файла или свободное пространство. 
          // ГркппаОбъектов при сохранении в индесном файле. сначала зарезирвировать в индексном файле номер для себя и набор индексных адресов для объектов
        //сохранить этот набор как ссылки на объекты, потом начинать сохраять объекты и сопоставлять номер индекса номеру байта в основном файле
        // это аболютно не похоже что делается сейчас (запись в ленту), первого этапа сохранения адресов индесксов нет вообще. дальше похоже только до или после сохранения объекта
        // надо запомнить номер позиции в индесном файле.
        // Хотя если ГруппаОбъектов используется только целиком, читается целиком, удаляется целиком, то вышеопианная процедура не нужна.Все работает нормально
        // Если группа это группа адресов (=узел), объекты это самостоятельные объекты с собственным адресом. Самостоятельные (независимые от группы), т.е. они могут меняться
        // незатрагивая группу

        public ПроксиОбъекта ДайПроксиОбъекта(int индекс)
        {

            var прокси = new ПроксиОбъекта()
            {
                АдресПримитива = АдресВФайлеПоИндексу(индекс)
            };
            return прокси;
        }
        public АдресВФайле АдресВФайлеПоИндексу(int номерИндекса)
        {
            return new АдресВФайле()
            {
                НомерБайтаВФайле = БайтВФайле(номерИндекса),
                АдресРегистратора = СобственныйАдресПримитива
            };
        }

        public void Переписать ( РАМОбъект примитив, int адрес) // существует опасность перекрытия данных
        {
            Писатель.BaseStream.Position = адрес;

            примитив.СохранисьВ(Писатель.BaseStream);

            Писатель.BaseStream.Position = адресСчетчика;
            СчетчикОбъетов++;
            Писатель.Write(СчетчикОбъетов);
        }
        public АдресВФайле ДобавитьВКонец (РАМОбъект примитив) //добавить в конец файла
        {
            var адресБайта = (int)Писатель.BaseStream.Length;
            Переписать(примитив, адресБайта); //установить указатель в конец и записать

            ПисательИндекса.BaseStream.Position = ПисательИндекса.BaseStream.Length; 
            ПисательИндекса.Write(адресБайта); // номер объекта по индексу* 4 = содержит 

            return new АдресВФайле() { НомерБайтаВФайле = адресБайта, СобственныйАдресПримитива = this.СобственныйАдресПримитива };

        }

        public override РАМОбъект this[Адрес адрес]
        {
            get
            {
                switch (адрес)
                {
                    case АдресИндексаВФайле а:
                        return ДайОбъектПоИндексу(а.НомерИндексаВФайле);
                    case АдресВФайле а:
                        return СоздатьКопиюОбъект(а);
                }
               
                return Пустота.Статик;
            }
            set { base[адрес] = value; }
        }

        public override РАМОбъект this[int индекс]
        {
            get { return ДайОбъектПоИндексу(индекс); }
            set { НаОбъектПоИндексу(индекс, value); }
        }

         int БайтВФайле(int номерИндекса)
        {
            ЧитательИндекса.BaseStream.Position = номерИндекса * 4;
            var адресОбъекта = ЧитательИндекса.ReadInt32();
            return адресОбъекта;
        }

        
        public РАМОбъект ДайОбъектПоИндексу(int номер)
        {
            ЧитательИндекса.BaseStream.Position = номер*4;
            var адресОбъекта = ЧитательИндекса.ReadInt32();

            Читатель.BaseStream.Position = адресОбъекта;  
            var прим = РАМОбъект.Создать(Читатель.BaseStream);
            return прим;

        }

        public void НаОбъектПоИндексу(int индекс, РАМОбъект объект)
        {
            ЧитательИндекса.BaseStream.Position = индекс * 4;
            var адресОбъекта = ЧитательИндекса.ReadInt32();

            Читатель.BaseStream.Position = адресОбъекта;
            int длинаОбъекта;
            длинаОбъекта = ЧитательИндекса.ReadInt32(); // вариант с записью длины в индекс
            // узнать длину сохраненного объекта, его тип
            var номерТипа= Читатель.ReadByte();
            
            var тип =  Хранилище.Типы[номерТипа];
            // для примитивов 
            
            длинаОбъекта = (int) тип.InvokeMember("Длина",BindingFlags.InvokeMethod, null,null, null );
            //для групп и строк
            длинаОбъекта = Читатель.ReadUInt16();

            // если тип объекта совпадает с типом сохраненного объекта и этот тип не группа = длины сохраненных объектов совпадают
           Переписать(объект,адресОбъекта);
            // если ттип не совпадает
            // то сравнить длину , если длина совпадает, то ттоже записать
            
            // если длина не совпадает 
            //то найти подходящее место 
                // в файле с удалениями есть
            // запомниттьпустое место

            int новыйАдресОбъекта=0;
            // запомнить новый адрес в индексе
            ЧитательИндекса.BaseStream.Position = индекс * 4;
            ПисательИндекса.Write(новыйАдресОбъекта);
            Переписать(объект,новыйАдресОбъекта);

            // записать в удаленных пусттое место адрес начала, длина, было бы не плохо отсортировать этот файл по длинам
            // еще вариант использовать 



        }

       

        // можно создать разреженный объект поток и распихать его в дыры
        public MemoryStream ЗаписатьВВиртуальныйПоток(РАМОбъект примитив) // 
        {
            var виртПоток = new MemoryStream();
            var писатель = new BinaryWriter(виртПоток);
            var кодТипа = Хранилище.кодыТипов[примитив.GetType()];
            писатель.Write(кодТипа);
            примитив.СохранисьВ(Писатель);
            
            return виртПоток;

        }
        // как его использовать 

        // 
        public static void Тест()
        {
            
            var адресДХ= Хранилище.Добавить(new ДисковоеХранилище() { ИмяФайла = "имя" }); // теперь Дисковое хранилище может восстанавливается открываться
            var хр=((ДисковоеХранилище)адресДХ.АдресВКучеПамяти());
            хр.Открыть();

            var д = new ДисковоеХранилище() {ИмяФайла = "дисковое хранилище"};
            д.Создать();
            var адресЦелого = д.ДобавитьВКонец(new ЦелоеЧисло(10) );
            var целое = д.СоздатьКопиюОбъект(адресЦелого);

            var проксиЦелого = д.ДайПроксиОбъекта(0);
            проксиЦелого.ИзменитьИзнутри(new ЦелоеЧисло(100));


            var адресСтроки2 = д.ДобавитьВКонец(new СтрокаЮникода() {Значение = "с"});
            var строкаПрочитнная = д.СоздатьКопиюОбъект(адресСтроки2);
            var адресСтроки3 = д.ДобавитьВКонец(new СтрокаЮникода() { Значение = "Строка" });

            var адресСтроки= хр.ДобавитьВКонец(new СтрокаЮникода() { Значение = "строка на диске" }); // строка не добавляется в Память, только на Диск
           

            Хранилище.Добавить(адресСтроки); // теперь можно по адресу добраться до самой строки
            
            //примитивы должны сохраняться вместе с адресом,иначе они будут потеряны, Дисковое хранилище можно полностью прочитать, последовательно и просмотреть все объекты
            // важна замена объекта по адресу, либо перезапись, либо перенаправление. Перезапись предполагает резервирование дополнительного места (байтов), перенаправление, должно содержать
            //новый адрес, который должен уместиться в старое пространство, т.е. строка не может быть меньше 4 байт(минимального адреса)


           
            var копияСтрокиВПамяти = адресСтроки.АдресВКучеПамяти();

            // теперь добавим адрес строки на диск
            var адресАдресаСтроки = хр.ДобавитьВКонец(адресСтроки); // теперь по этому адресу храниться (1.номер ДХ  в Хранилище и 2.номер строки в ДХ) 1 здеь лишниее
            //похоже адрес в файле не должен содержать адреса ДХ в хранилище- это уже  


            
            
        }

    }
}
