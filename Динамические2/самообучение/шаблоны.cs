using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Динамические
{
    /*
     * шаблон сокращенный- минимизация
     * в предложении есть ключивые слова, остальные можно понять из контекста
     * в слове есть ключивые буквы 
     * сокращения в предложениях, длинные точные названия можно сокращать заменять более короткими
     * для этого надо выбрать некоторые слова, остальные скрыть
     * 
     * 
     * 
     * многопоточность: разные сигналы могут порождать свечение (увеличение веса) некоторых групп одновременно, потом можно отбирать самые яркие
     * так анализ строки можно начинать одновремено с каждой подстроки или двухмерного изображения с каждого квадрата 2х2 или 3х3 или областей с перепадом яркости больше заданной величины
     * 
     * 
     */
    public class ЯчейкаВыбораТипа //узел выбора, ПЕРЕМЕННАЯ с выбором типа
    {
        private object Значение;
        public List<string> ДоступныеТипыВарианты;
        public bool УстановитьЗначение( object значение)
        {
            var т = значение.GetType();
            foreach (var вар in ДоступныеТипыВарианты)
            {
                if (т.Name == вар)
                {
                    Значение = значение;
                    return true;
                }
            }
            return false;
        }

    }

    public class ЯчейкаВыбораСтроки //узел выбора
    {
        private string Значение;

        public List<string> ДоступныеТипыВарианты;
        public bool УстановитьЗначение(string значение)
        {
            foreach (var вар in ДоступныеТипыВарианты)
            {
                if (значение == вар)
                {
                    Значение = значение;
                    return true;
                }
            }
            return false;
        }

    }

    public class ШаблонВыбораСтроки //узел выбора - группировка = концепция = условие ИЛИ
    {
        public string Имя; // супер сильно ускорит проверку
        public List<string> ДоступныеВарианты;
        public bool ПроверитьСовпадение(string значение)
        {
            foreach (var вар in ДоступныеВарианты)
            {
                if (значение == вар)
                {
                    return true;
                }
            }
            return false;
        }

    }
    public class ЯчейкаВыбораСтрокисШаблоном //узел выбора
    {
        private string Значение;

        public ШаблонВыбораСтроки ШаблонВыбораСтроки;
        public bool УстановитьЗначение(string значение)
        {
            if (ШаблонВыбораСтроки.ПроверитьСовпадение(значение))
            {
                    Значение = значение;
                    return true;
            }
            return false;
        }

    }

    public class ШаблонСтруктурыСтрок //узел точной структуры
    {
        public string Имя;
        public List<string> Структура;
        public bool ПроверитьСовпадение(List<string> список)
        {
            if (список.Count != Структура.Count) return false;
            for (int index = 0; index < Структура.Count; index++)
            {
                if (список[index] != Структура[index])
                {
                    return false; // можно вернуть место ошибки
                }
            }
            return true;
        }
    }

    public class ШаблонПовторовСтрок //узел повторной бесконечной структуры
    {
        public string Имя;
        public string Повтор;
        public bool ПроверитьСовпадение(List<string> список)
        {
            if (список.Count ==0) return false;
            foreach (var эл in список)
            {
                if (эл != Повтор) return false;
            }
            return true;
        }
    }

    // можно добавить диапазоны, исключения (А-В), шаблон с подсчетом повторов, с меньшим количеством повторов, большим количеством повторов, 
    //попаданием в диапазон повторов (нечеткая логика)
    // условие может быть любое например объект нужного типа,который имеет два поля, начинающиеся с "а", т.е. есть набор условий связанных логическими цепочками

    public class ШаблонИСтроки // условие И  Данный шаблон всегда будет давать ЛОЖЬ если есть два разных условия 
    {
        public string Имя;
        public List<ШаблонУсловиеНачинаетсяС> Условия; 
        public bool ПроверитьСовпадение(string значение)
        {
            foreach (var вар in Условия)
            {
                if (! вар.ПроверитьСовпадение(значение))
                {
                    return false;               // по сравнению с ИЛИ
                }
            }
            return true;
        }

    }

    public class ШаблонНечеткоеИСтроки // условие нечеткое И = сумматор
    {
        public List<ШаблонУсловиеНачинаетсяС> Условия; 
        public int ПроверитьСовпадение(string значение)
        {
            var степень = 0;
            foreach (var условие in Условия)
            {
                if (условие.ПроверитьСовпадение(значение))
                {
                    степень++;               // по сравнению с ИЛИ
                }
            }
            return степень/Условия.Count;
        }
    }

    public class ШаблонУсловиеНачинаетсяС // условие И = сумматор
    {
        public string ДоступныеВарианты;
        public bool ПроверитьСовпадение(string значение)
        {
            return значение.StartsWith(ДоступныеВарианты);
        }

    }

    // обучаемая структура
    public class ШаблонСимвол: ШаблонС //узел выбора - группировка = концепция
    {
        public char ДоступныйВариант;
        public override bool ПроверитьСовпадение(object значение)
        {
                if ((char)значение == ДоступныйВариант)
                {
                    // активировать связанные шаблоны
                    foreach (var исх in ФокусВывода)
                    {
                        исх.ПроверитьСовпадение(null);
                    }
                    return true;
                }
            // если нет совпадения деактивировать шаблоны из Фокуса
                foreach (var исх in ФокусВывода)
                {
                    исх.ДеАктивировать(null);
                }
            ФокусВывода = Исходящие;
            return false;
        }

        public override void ДобавитьВСписокОжидания(object вышестоящийШаблон)
        {
            Активен=true;
            // добавить в фокус ввода
            //ФокусВывода= new List<ШаблонС>();
            ФокусВывода.Add((ШаблонС)вышестоящийШаблон);
            //либо увеличить веса связей
        }

        public override void ДеАктивировать(object значение)
        {
            throw new NotImplementedException();
        }
    }

    public abstract class ШаблонС //узел выбора - группировка = концепция
    {
        public string Имя; // супер сильно ускорит проверку
        public bool Активен = false;
        public List<ШаблонС> Исходящие = new List<ШаблонС>(); // Шаблоны след слоя известные
        public List<ШаблонС> ФокусВывода = new List<ШаблонС>(); // Шаблоны след слоя активные
        //public List<Связь> Связи = new List<Связь>();
        public abstract bool ПроверитьСовпадение(object значение);
        public abstract void ДобавитьВСписокОжидания(object вышестоящийШаблон); // обратная активация предыдущего слоя
        public abstract void ДеАктивировать(object значение);


    }

    public class ШаблонСтруктурыСтрокИнт :ШаблонС //узел точной структуры
    {
        public List<ШаблонС> Структура; // входящие
        private int ТекущийВходящийШаблон= 0;
        public override bool ПроверитьСовпадение(object значение)
        {
            ТекущийВходящийШаблон++;
            if (ТекущийВходящийШаблон <= Структура.Count)
            {
                // активировать следующий шаблон
                // остальные деактивируются не попадая в фокус
                Структура[ТекущийВходящийШаблон].ДобавитьВСписокОжидания(this);
                
            }
            // если дошли до конца - шаблон сработал
            // активироввать следующий слой
            foreach (var исх in ФокусВывода)
            {
                исх.ДобавитьВСписокОжидания(null);
            }
            return true;
        }

        public override void ДобавитьВСписокОжидания(object вышестоящийШаблон)
        {
            Активен = true;
            // добавить в фокус ввода
            //ФокусВывода= new List<ШаблонС>();
            ФокусВывода.Add((ШаблонС)вышестоящийШаблон);
        }

        public override void ДеАктивировать(object нижестоящийШаблон) // неудача ожидания, 
        {
            //Состояние = "неакт";
            ТекущийВходящийШаблон = 0;
        }
    }

    public class Обучение
    {
        void Начало(string строка)
        {
            var известное = new List<ШаблонСимвол>();
            var концепция1 = "UTF-8";
            var концепция2 = "буква";
            var Фокус1 = new List<ШаблонС>();
            var a1 = new ШаблонСимвол() {ДоступныйВариант = 'а'};
            
            var a11 = new ШаблонСимвол() { ДоступныйВариант = 'b' };
            var a2 = new ШаблонСтруктурыСтрокИнт();
            a2.Структура.Add(a1);
            a2.Структура.Add(a1); // аа

            a1.Исходящие.Add(a2);
            Фокус1.Add(a1); Фокус1.Add(a2);

            foreach (var символ in строка)
            {
                var i = 0;
                // поиск в фокусе символа
                foreach (var шаблонС in Фокус1)
                {
                    if (шаблонС.ПроверитьСовпадение(символ)==true)
                    {
                        i++;
                    }
                }
                if (i>0) continue; // найдено несколько подходящих шаблонов
                // если найден шаблон возбуждаются его  связи , переход к новому символу

                // если не найден  активные шаблоны тормозяться


                // обучение создание новых шаблонов
                if (известное.Find(a=> символ== a.ДоступныйВариант)==null)
                {
                    известное.Add(new ШаблонСимвол(){ДоступныйВариант = символ, Имя = концепция1});
                }
            }
        }
    }

}
