using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Динамические
{

    // этот адрес ведет себя по разному для входящей и исходящей связи 
    

    public class ЦелоеНаДиске: Примитив
    {
        public string ИмяФайла; // это адрес дискового хранилища - это адрес 
        private Stream поток;

        static ЦелоеНаДиске()
        {
            РеакцииНаКоманды.Add(new РеакцияНаКоманду() {Имя = new СтрокаЮникода("ДайЗначение") , Инструкция = typeof(ЦелоеНаДиске).GetMethod("ДайЗначение") });
        }

        public ЦелоеНаДиске()
        {
            
        }

        public  РАМОбъект УстановитьСвязь() // это связь, которую надо закрывать
        {
             поток = File.Open(ИмяФайла,FileMode.OpenOrCreate,FileAccess.ReadWrite);
            return null;
        }
        public ЦелоеЧисло дайЗначение() 
        {
            ЦелоеЧисло знач = new ЦелоеЧисло(); // в целомчисле надо разделить сохранние значения и сохранение всего объекта (свойства+значение)
            знач.Восстановить(поток); //плохо что читается и код типа каждый раз 

            return знач;
        }

        //public override object НаЗначение(object значение)
        //{
        //    ((ЦелоеЧисло) значение).СохранисьВ(поток);
        //    поток.Flush();
        //    return true;
        //}

       
    }

    // этот объект должен пребразовываться в Целое  и обратно входить в Дисковое хранилиеще и обратно
    // сервер дискового хранилища (в памяти значения нет    объекта в памяти нет адрес значения 
    //этот объект посредник он получает команды по одному адресу и отправляет по другому
    public class ЦелоеСервер : Примитив
    {
        // это тоже своего рода поток куда сохраняется значение

        // кэш в памяти читается отсюда, когда сохраняется меняется и кэш, когда создается происходит первое чтение 
        //само Целое это объект в памяти например в памяти Хранилища ДайЗначение значение выдается из памяти 
        // ЦелоеНаДиске свойства содержат адрес файла Значение выдается с диска
        // 
        private ЦелоеЧисло _целое;
        public ЦелоеЧисло ЗначениеВпамяти { get{return _целое;} set { _целое = value;} }
        public void ЗаполнитьКэш()
        {
        }

        public ЦелоеНаДиске ЦелоеНаДиске; //исходящее - команды только туда
        public ТСПСвязьВходящая Слушатель; //универсальный слушатель - входящее соединение
        public override void СохранисьВ(BinaryWriter писатель) //сохранить объект
        {
            base.СохранисьВ(писатель); // сохранить адрес типа в Хранилища
            // сохранить адрес дисковое хранилище
            ЦелоеНаДиске.СохранисьВ(писатель);
            // сохранить адрес сетевой 
            Слушатель.СохранисьВ(писатель);
            
        }

        public override РАМОбъект Восстановить(BinaryReader читатель)
            //востановить объект без значения из потока Хранилища
        {
            var объект = base.Восстановить(читатель);
                // создать пустой объект экземпляр по адресу из справочника типов Хранилища
            // востановить адрес дискового хранилища
            ЦелоеНаДиске = (ЦелоеНаДиске)РАМОбъект.Создать(читатель.BaseStream);
            //восстановить адрес в сети
            Слушатель = (ТСПСвязьВходящая) РАМОбъект.Создать(читатель.BaseStream);
            Старт();

            return this;
        }

        
        public РАМОбъект ОбработатьКомаду(Команда команда) // позволяет удалить обработчики команд "Дай/НаЗначение", но затрудняет запуск команд 
        {
           return ЦелоеНаДиске.ВыполнитьКоманду(команда); // тупо все пересылается 

        }

// Это можно заменить на обработать команду и просто переслать 
        //public override object ДайЗначение() // тупая переадресация 
        //{
        //    var значение = ЦелоеНаДиске.дайЗначение();
        //    return значение;
        //}

        //public override object НаЗначение(object значение)
        //{
        //    ЦелоеНаДиске.НаЗначение(значение);

        //    return true;
        //}

        

        public void Старт() // запуск слушателя - цикла опроса входящих сообщений 
        {
            Слушатель.ОбслуживаемыйПРимитив = this;//установление обратной сявзи

            Слушатель.Старт();
        }

        public void Стоп()
        {
            Слушатель.Стоп();
        }
        
    }

    //это универсальная входящая связь, если ЦелоеСервер заменить на другой примитив тоже будет работать
    // посредник получает команду пересылает, возвращает результат
    public class ТСПСвязьВходящая: Адрес
    {
        public string IPАдрес = "127.0.0.1"; // смена адреса должна перезапускать сервер Стоп() Старт()
        public int порт = 100;
        public ТСПАдрес АдресТСП; // это адрес на локальной машине, клиент на удаленном компе увидит другой адрес,

        public bool Активен = true;
        public РАМОбъект ОбслуживаемыйПРимитив; //исходящее соединение - для активности туда посылаются команды 

        private TcpListener Слушатель; //входящее соединение 
        private TcpClient клиент; // клиент только один 
        private Socket сокет;

        // это перенести в активность
        private List<object> ПодписчсикиНаСобытия; // Подписчики могут передавать действия любой сложности, а не только установление связи для сообщения об изменении, например удалении себя из получателей (онднкратный получатель)
        private План СписокДействийСторонний;
        private string состояние = "";
       





        public void Старт() // запуск в отдельном потоке
        {
            Слушатель = new TcpListener(IPAddress.Parse(АдресТСП.IPАдрес), АдресТСП.порт);
            Слушатель.Start();

            Активен = true;

            var процессор = new Thread(ЦиклОбработкиСоединений);
            процессор.Name = "ЦиклОбработкиСоединений";
            процессор.Start();
        }

        public void Стоп()
        {
            Слушатель.Stop();
            Активен = false;

            клиент.Close();
        }

        public void ЗапуститьСервер()
        {
            // регистрация в службе TCPIP
            Слушатель = new TcpListener(IPAddress.Parse(АдресТСП.IPАдрес), АдресТСП.порт);

            //var задача = Слушатель.AcceptTcpClientAsync();
            //object состояние = null;
            //var результатВызова = Слушатель.BeginAcceptTcpClient(обратныйВызов, состояние);


            Слушатель.Start();

            Активен = true;

            while (Активен) //цикл обработки подключений
            {
                // ожидание подключения
                состояние = "ожидание подключения";
                сокет = Слушатель.Server;
                //сокет.Listen(1);

                //ЦиклОбработкиСоединений();
                состояние = "новое входящее соединение установлено";// событие

                клиент = Слушатель.AcceptTcpClient(); //  получение первого 

                состояние = "новое входящее соединение установлено";// событие
                //Начало сеанса

                var адресПодключившегося = (IPEndPoint) клиент.Client.RemoteEndPoint;
                var IP = адресПодключившегося.Address; // здесь можно отфильтровать входящие соединения

                NetworkStream поток = клиент.GetStream(); //не очень удобный вариант совмещение входящего и исходящего буфера

                var читатель = new BinaryReader(поток);

                // получить команду
                // протокол обмена сообщениями
                состояние = "получение сообщениий";
                var протокол = РАМОбъект.Создать(поток); // получается Метка протокола общения, например "http" или описанный ниже, протокол это набор методов по обработке получаемых байт (распознования их)
                                                                // список поддерживаемых команд, сценарии обмена сообщениями (в том числе команды) 

                var команда = (Команда)РАМОбъект.Создать(поток); //здесь придти может любой примитив

                состояние = "получение закончено, обработка команды";
                РАМОбъект результат= new СтрокаЮникода() {Значение = "ошибка"};
                if (команда.Имя.Значение == "ТипОбъекта")
                    результат  = new СтрокаЮникода( ОбслуживаемыйПРимитив.GetType().Name);
                
                if (команда.Имя.Значение == "ДайОбъект") // это уже внутренние команды Сервера
                    результат = ОбслуживаемыйПРимитив.ВыполнитьКоманду(команда);
                if (команда.Имя.Значение == "НаОбъект")
                {
                    // если тип пришедшего примитива совпадает с типом местного, то (а так вместо Целого здесь появиться что угодно )
                    // по идее здесь нужно создать новый Примитив и воостановить тот что передан в Параметрах
                    // АдресОбсуживаемогоПРимитваВКуче содержит эту команду "НаЗначение" если там ЦелоеВфайле
                    ОбслуживаемыйПРимитив = команда.Параметры[0];
                    ОбслуживаемыйПРимитив.ВыполнитьКоманду(команда);// = команда.Параметры[0]; //здесь надо отдавать команду , переадресовывать команду 
                    // так можно запустить любую команду, хотя там где потоки они не запустяться, запустяться только 2 дай/на и запустить сервер
                    // можно сделать список команд из делегатов, лучше сделать команды примитивы, которые будут сохраняться и востанавливаться
                }
                   

                    //выполнить команду - это сообщение появляется если это уже не примитив
                    if(команда.Имя.Значение == "ВыполнитьКоманду")
                    результат = ОбслуживаемыйПРимитив.ВыполнитьКоманду((Команда) команда.Параметры[0]);
                // если это группа то дайОбъект дополняется  ДайОбъект(номер), ДайЧастьОбъектов (начало, конец)
                // НаОбъет(номер, объект) На ЧастьОбъектов(начало, конец, группаОбъектов) - это команды к Группе, не нужны 
                // есть еще потоки ДайДанныеПотока - здесь надо связь сохранить и даже поддерживать отправлять данные и прослушивать паралельно входящие команды 
                // хотя в команду ДанныеПотока передается адрес куда давать или сам поток и там в отдельном логпроцессе идет передача
                // ВОЗМОЖНО нужен другой объект-сервер специально для этого 

                // это сообщение появляется когда у активности одновременно более одной входящей связи 
                // если связь одна, то активность блокирована- никто не может внести изменение
                // 
                if (команда.Имя.Значение == "СообщиОбИзмененииОбъекта") // добавь меня к событию изменения объекта , удали меня из подписки 
                {
                    var обратныйАдрес = команда.Параметры[0];
                    ПодписчсикиНаСобытия.Add(обратныйАдрес);//+ сохранить запускаемое действие, действие простейшее = установить связь и все = сигнал = преывание 
                    // можно добавить сюда клиент, поток
                    // режимы: сохранять связь, разорвать связь (тогда удаленный должен быть сервером)
                    // значение примитива меняется через группу, группа вносит изменение в элемент

                    результат = new СтрокаЮникода("Готово");

                }

                // попытаться отправить результат (связь может быть уже потеряна)отправить результат
                состояние = "передача";
                результат.СохранисьВ(поток);

               // завершить сеанс - сеанс может быть продлен, тогда нужны внутренние команды начала сеанса и конца (конец может быть + истечение времени ожидания)
                клиент.Close();
            }
            // закрывается процессор
        }

        private void ЦиклОбработкиСоединений()
        {
            while (true)
            {
                var ТСПКлиент = Слушатель.AcceptTcpClient();
                состояние = "новое входящее соединение установлено";// событие
                // два варианта создать новый нить и передать обработук туда либо обрабатывать каждое здесь
                // каждый сокет это отдельная связь, если их много то связей много, т.е. по одному адресу может существовать много связей 
                // создать новую связь
                // для фиксированой связи проверить подлинность удаленного объекта (адрес, пароли ) если это неизвестный, то закрыть соединение 
                var  потокОбработкиПоступающихДанных = new Thread(ЦиклОбработкиПоступающихДанных);
                потокОбработкиПоступающихДанных.Start();


            }
           
        }

        void ЦиклОбработкиПоступающихДанных()
        {
            var ожидаемаяСкоростьПередачи = 10000;
            NetworkStream поток = клиент.GetStream();
            //var максимальнаяСкорость
            DateTime началоПередачи = DateTime.Now;
            DateTime конецПередачи ;
            double скоростьЧтенияЗаполненногобуфера; // скорость в секунду
            bool передачаИдет=false;
            int прочитаноБайт = 0;

            while (true)
            {

                if (клиент.Available>0 )
                {
                    if (!передачаИдет)
                    {
                        началоПередачи =  DateTime.Now;
                        передачаИдет = true;
                    }
                    
                    for (int i= 0; i<клиент.Available; i++)
                    {
                        var байтт = поток.ReadByte();
                        прочитаноБайт++;
                    }
                    
                    // к концу чтения могут снова поступить данные

                    // читать пока не будет прочитан ожидаемый объект . А вдруг зависло? Надо проверять через промежутки времени 

                }
                else
                {
                    if (передачаИдет)
                    {
                        конецПередачи = DateTime.Now;
                        передачаИдет = false;
                        скоростьЧтенияЗаполненногобуфера = прочитаноБайт/(конецПередачи - началоПередачи).TotalSeconds;
                        прочитаноБайт = 0;
                    }
                }
               

                Thread.Sleep(100);// обязательное ожидание 
            }
        }

        public void АссинхроннаяОбработка(NetworkStream поток) // параллельно может идти запись 
        {
            //
            var объект = РАМОбъект.Создать(поток); // связь может застрять посредине чтения , если зависание больше нормы разорвать соединение 
            // необходима синхронизация обработки данных

        }
    }
}
