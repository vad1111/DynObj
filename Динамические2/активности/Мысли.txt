

активности могут зацикливаться

лучше указывать связи в активностях ( входящие, исходящие, двусторонние, одностороние)
между активностями могут появляться посредники и исчезать, вставка активнсти в одностороннюю связь= создать новую активность, скопировать связь в исходящую,








создать универсальную процедуру обучения
старый вариант создавать команды (запомнить информация ) создать функцию, выполнить функцию, показать функцию, изменить функцию, создать клон функции, удалить функцию
переименовать функцию, 
обучение посредством нечетких функций , создать нечеткую функцию, найти способ реализации, путем задания вопросов пользователю


нечеткая функция
название команды ( сложить число1 и число 2) 
переченнь переменных (вхоодящие переменные, требуемый результат, примеры  )сложить 2 и 3 - результат 5 
способ вычисления ( вариант1 запомпнить успешные и неуспешные примеры ) (вариант2 набор реакций (частный случай последовательность действий )  )
запомни пример( команда = сложить 2 и 3 , результат 5) из примеров можно выделить шаблон - (сложить (2,3) и (3,4), результат (5,7)
сложить (п1) и (п2), результат (р)
п1- тип: число
п2 - тип: число
(2,3)(5)
(3,4)(7)

команда (ответь на вопрос) сколько будет сложить 2 и 3, реакция = сложить 2 и 3 будет 5 или краткий вариант - 5
прмая команда - сложить 2 и 3, ответ - 5, что 5? ответ- результат на команду сложить 2 и 3 
запомни шаблон (команда = сложить (вопрос=что?, тип параметра=число (1)) и (вопрос=что? , тип параметра= число (2)), результат = результат вычесления , как вычислить  )
параметр ассоциируется с вопросом, с типом параметра, с именем параметра ( имя параметра = имя типа + номер)

запиши в файл ммм, строку "апрарпа"
вопрос: куда записать? 
какие варианты? 
(варианты: в конец файла, в начало файла, в позицию (номер) )
полная команда "запиши (куда=в файл(имя)), (что), (куда в файле)"
это корректнее "запиши (что) (куда = в файл (мм), в позицию (сс)) (как) (когда) (зачем)" для запиши (когда= сейчас), (зачем )

запомни команду: (текст команды)
шаблон команды: (что сделать? глагол в пов.накл) (что) (куда) (когда) (как) - это шаблон
шаблон (что) может иметь несколько объектов (что,что,..) (что и что) 
(куда) это адрес (куда( куда ...)) вложенные узлы
(когда) 
(как) могут содержать уточнения (путем безналичного перечисления, путем передачи наличными)
(сделай сам, передай команду другому)

частый шаблон (название типа)(имя) (пример:буква а)

процедура выполнения команды 
1. найти шаблоны команды по наибольшему совпадению, сначало поиск по глаголу, потом по параметрам, 
2. найти соответствующие параметры, 
3. найти неизвестные параметры, 
4. спросить неизвестные парметры
5. получить неизвестные параметры
6. попробовать выполнить команду
7. отчитаться о выполнении команды 

требуемые параметры можно получить из списка действий, в списке действий есть словарь переменных, когда начинаешь выполнение , оказывается что это переменная не определена 
словарь переменных это множество доступных объектов - окружение выполнения команды 
термин переменная возникает в шаблонах как узел шаблона типа (варианты), варианты могут перечислениями, диапазонами, в перечислении может быть конкреьные объекты, или тип(типы) объектов

формирование шаблона можно представить как блок кода
пояление слова, можно заменять на команду= создатьПеременную, фраза будет состоять из словаря-списка переменных 
похожие слова добавляться не будут ( число добавиться один раз) т.е. разбивка по словам не правильна 
набор предложений  

шаблон общения 
1. (получен вопрос) -(поиск ответа)- (ответ)
2. (команда)- (выполнение команды) - (отчет)
3. (команда)- (попытка выполнения команды)- (запрос недостающих параметров)- (получение недостающих параметров)- (выполнение команды)- (отчет)


3 отличается от 2 дополнительными действиями

процесс обучения
2+2 - запомнить - поиск реакции - если нет реакции - вопрос (непонятный текст что это? или что делать?) ответ (ответь 4)- ожидание (команда или определение "это ммм") - (конец сесии обучения)
к объекту "2+2" добавить "ответь 4" 
ответь (ппп) - УЖЕ нужен разбор по словам, словарь слов, ассоциация что это команда, ассоциация с шаблоном команды, ассоциация с действием, выявление параметров 
ассоциировать "2+2" с действием ответь и параметром 4

при распознании должна получиться следущая структура
предложение {
СписокОбъектов типа Слово или пробел}
слово это список букв
пробел спиок пробелов или количество пробелов
предложение(слово(рлор), пробел(1), слово(впрыпвр))

если очередной символ начало текста, создать новое преложение
список ожидаемых шаблонов = слово и пребел, взять из шаблона предложения
для каждого из ожидаемых шаблонов
	если очереднйо символ подходит к шаблону слово, 
	то (создать новое слово добавить ссылку на изначальный текст и ссылку напредложение, 
		добавить в слово символ, добавить номер начала слова в изначальном тексте, если получен объект символ, то он имеет ссылку на текст и номер в тексте
		добавить шаблон слова в список заполняемых шаблонов
	иначе 
	если .. подходит пробелу, создать новый пробел, иначе исключить пробел из ожидания
взять следущий символ, создать объект символ( ссыка на текст, номер в тексте, тип смвола = (пробел или буква))
список ожидаемых шаблонов = пробел 
для каждого заполняемого шаблона
	попытаться добавить символ в шаблон слова
		если текущий символ буква, то добавить в список букв
		иначе в слове присвоить номер конца слова, добавить слово в предложение,
	если добавить не удалось
попытаться добавить в альтернативные шаблоны, у нас это пробел
	если текущий символ пробел, то создать объект пробел , добавить в его список текущий символ
список запоняемых шаблонов = шаблон пробела
список альтернативных шаблонов = шаблон слова


глобальный фокус - это большая база описаний ситуаций, и набор реакций 
описание ситуации - может быть очень длинным ( появился символ, этот символ буква, он появился после другого, символ пришел от активности ччч, идет процесс распознания текста, 
цель распознать известные слова , индекс цикла = 100 )	и реакция на него
это можно рассмтривать как функцию и его входящие параметры 
не все параметры нужны для реакции
реакция может создать еще одну переменную и добавить ее в описании ситуации, изменить существующую переменную, удалить переменные, 
здесь фокус совпадает со словарем внутренних переменных 
каждое действие получает список всех этих переменных (текущее состояние)
функции может быть передан ограниченный перечень переменных (часть состояния )
после завершения действия текущее состояние фокуса меняется
фокус должен найти следующее подходящее действие, для линейной программы просто берется следующее действие из списка программы без оценки состояния
т..е реакция тупая взять следующую команду - выбора нет 
в спикске команд есть и действие выбора ( проверяется наличие некоторых переменных, их сравнение и затем выбирается новая ветка для работы)

простейший фокус это словарь, получен ключ, выдан объект = совершено действие
"2+1" - действие "ответить равно(3)" (ищеться данный текст, если находиться, выполняется, если нет - добавляется и проситься реакция, добавляется реакция  
								может искаться как подстрока, может разбиться по частям (1+,1+2) - (1+3)- может и быть реакция (4)	)
"1+2+1" - действие "отвеить (4)"
входящий текст запоминается как есть, без минимизации чистая история
"2" -"это число" = заменить на "число" 
"1" - "это число"
"число + число" - действие ответить( сложить( число1 , число2))
"2+1"- тут более сложно заменить 2 и 1 на обобщения число и число = "чмсло + число", эта реакция уже есть 
т.е. реакция на появление текста уже не простой поиск, = разбить текст на части, найти реакции на эти части найти "2" будет найдено определение (группа) "это число"
заменить части текста на определения, снова поиск = уже ищуться функции , т.е. надо запоминать промежуточные результаты , создать собственный словарь, запоминать разбивку строки на части и искать
	их в истории, создавать новую строку и снова искать в истории, если не найдено повторить в разбивку, если найдено сделать подстановку параметров 

Из истории можно заметить повторы, 
минимизация заключается в обобщении 2+1=3 и 2+2=4 - (2+,2+)(1,2)(=)(3,4)
1+2=3 - (2,2,1)(+)(1,2,2)(=)(3,4,3) = (группа1)+ (група2) = (группа3)
т.е. запоминается уже не текст, а целая структура, т.е. выявляется шаблон - это список из списков , списки потом именуются.
автоматом появились 3 группы, если их сравнить они будут похожи, значит это одна группа объектов 
можно из групп, выбросить похожие и отсортировать первые две группы совпадут, значит они одинаковые по составу, но разные по порядку 
состав группы может иметь пересечения или нет, тогда они сопадут на процент их пересечения 
порядки групп также могут иметь пересечения 
55+2=57 2+1=3 алгоритм разбивки разных по длине строк ? тоже что слова обычного языка 

можно забыть все 2+1 и т.д. увидел 2 замени на число и ищи функцию(алькулятор), реакция полностью изменилась, хотя может остаться и простой поиск в истории

можно добавить запоминание переменных (переменная индекс = 10) если их много выдается последний 
"переменная индекс =" выдаст 10 просто найдет
"переменная индекс2 = 1" - реакция добавить в справочник переменные (индекс2, 1)



событие: появился текст на входящем устройстве
окружение: входящее устройство принимающее команды (ожидание ,  интерпритатор текста, список реакций 
ожидание: выполнение команды содержащейся в тексте
реакция: созданеи команды распознать текст


		      
			  минимизация 
			  группы активностей могут (должны) сами искать способ минимации связей, создавать группы, специализироваться 

память списка активность1- активность2-активность3 - это связанный список
пустой элемент   \______________________/
активность 1 это ветвление - варианты ( активность2 или активность3) активность 2 срабатывает по сигналу, например а, активность 3 по любому другому сигналу
!!!поэтому пустой сигнал = это любой сигнал, кроме определенных
выбор (пустота или а) - 2 выхода, у меня в шаблоне почему-то 1 

слово - это накопление букв приход сигнала от активности буква добавляет букву(создает новую активность), приход сигнала от другой активности, вызывает срабатывание передачи 
слово это список активностей символов, которые являются буквами, т.о. слово (событие= одновременный приход символа и приход буква) у меня, символ передает сама активность буква
символ как бы окрашивается, получает метку= буква и передается слову, если символ не имеет этой метки (у меня =нуль), то срабатывает событие нового слова 
слово это новый шаблон состоящий из списка букв
т.о. слово это генератор шаблонов 
"новое слово" имеет ссылку на создавший ее шаблон - что является его определением "слово"
шаблон "слово" может передавать транзитом символ для поиска существующего слова, если слово найдено, то не создается новое слово, а передается адрес(ссылка) на существующее слово
хотя существующее слово может запустить другие активности, в том числе и отключить сам шаблон "слова"

1.одновременный приход реализуется передачей сигнала вместе с номером такта, сначала приходит вызов от символа, запоминается символ и номер такта, затем от буквы, сравнивается номер такта
если одинаковые такты, то символ обрабывается (ищется, добавляется), если приходит символ, но не приходит буква, активность сбрасывается , передается ссылка на найденное или созданное слово
Проблема: буква  появляется позже или раньше (зависит от порядка в рассылке) за это время может прийти новый символ, старый символ потеряется, 
хотя нет рассылку делает символ, если буква ранше, сначла сработает пояление буквы в слове, потом появление символа в слове, буква активирует слово, символ делает срабатывание
2.может нужно передавать акрашенный символ, символ имеет уже готовые определения (буква, русская и т.д)
 


 а как сделать нумерованный список во как ак1 (вход=счетчик, выход = (ак2, ак3))

рекурсия активность1- акти2-
			\_________/

должен быть выход из рекурсии а1- условие выхода(выход или переход к а1) приход определенного сигнала указывает на выход, т.е. у состояния2 два входных сигнала и два выхода
прямо обычный цикл с условием
где тут словарь переменных 
активность подсчета прохлддов через нее, достижение заданного количества меняет ее выходной сигнал, простейший индекс с ++ это входная активность for
активность = подсчетПроходов(Макс количество ) - счетчик, выходнаяя активность 1 (выход из цикла ) вторая (тело цикла)

функции в шаблонах
это хранение пар, троек значений (красный, красная)(он,она) так выявляются шаблоны, 
красный- он
красная-она
она и он - тип переменной , слова , ассоциация, вместо имени местоимение
понятие = "красный цвет" 
объект имеет красный цвет : красный объект = объект красного цвета  = объект, который имеет красный цвет
"цвет" это словарь 
наименование объекта с перечислением атрибутов= (тип объекта) (звук имя объекта) (атрибуты )
(атрибуты)= атрибут свойства (цвет, материал, форма) , атрибут принадлежности (родство,собственность), атрибут местонахождения(стоящий, лежащий) , (сделанный)
каждый объект имеет словарь атрибутов 
а это звук

класс это способ минимизации расходов памяти, 
если объекты имеют схожие части (блоки большие чем замена ), то выгоднее создать новый объект содержащий повторяющиеся части и соединить ее с экземплярами 
если объекты сами решают как объединиться, то подобные части будут стремиться слиться или если это активности, то специализироваться
если активности делают одинаковую работу, то можно заменить ее на одну активность, хотя если работы много надо увеличивать количество рабочих
клетки тела похожи на шалблоны ( фабрики объектов) им дают материал, и они  собирают из него в нужных узлах новые клетки, в лунке ногтя есть шаблоны создания ногтевых клеток, для этого нужны определенные 
микроэлементы, возможно посылается сигнал потребности в том или ином микроэлементе.


	1.расширение- это возможность дополнения объектов
т.е. объект изначально список адресов, затем список пара- (адрес имя, адрес), затем тройка (адрес имя, адрес тип, адрес объекта) также добовляется список атрибутов
(адрес имя, тип, атрубуты, адрес самого объекта )

каждый адрес (например имени) можно заменить на группу объектов, при этом первым элементом должен быть адрес имени, остальное что угодно (второй элемент - новая группа )
тоже с остальными адресами, возможно там будет адрес типа переадресации (расширения) , чтобы 
это соответственно нужно отразить в методах которые к обращаются к данному объекту 
	2. минимизация - создание структур общих для объектов, например тип: содержит описание, тип, атрибуты, общие для нескольких объектов (например целое число )
т.о. объект будет состоять из ссылки на описание (тип) и само значение
Это реализуется расщеплением группы объект(описание, значение) на тип(описание) объект (тип, значение), т.е. список адресов (описания) заменяется на один адрес этого описания, кроме того 
группа описания , получает еще имя, именованная группа 
такая опреация выгодна для экономии памяти, но скорее всего создает проблемы для расширения, т.к. добавление нового атрибута для одного объекта, меняет сразу все экземпляры
т.е. расшмрение предполгает создание снова полного объекта и потом уже его расширения 
если надо изменить сразу все экземпляры типа, то расширение вполне реализуется.

Самый выгодный вариант объекта безописательный, только список адресов (Tuple хотя это список без имен, но с типами), что там хрен его знает, только некоторое действие может это расшифровать(типа воостановить())
но список может содержать как однотипные объекты (частицы)-это шаблон ряд, так и разнотиные объекты (части) - это шаблон структура
список частиц это просто список
список частей это уже словарь, где каждый объект имеет свое уникальное в пределах словаря имя (это можно реализовать либо двумя именованными списками, либо списком пар (ключ, значение) первый элемент, 
 тогда содержит (имя ключа, имя значения) ) ключом может быть имя, а может быть имя+тип+атрибуты (одновременное совпадение )
 (имя ключа, имя значения) не обязательно 

Любой список можно разделить на части, сделать группу (групп, объектов), каждой группе можно присвоить уникальное имя, получиться словарь.
Хотя распознание строки текста делит группу на части, части имеют тип, но не имеют имени, только структура точного слова можно назвать именем

Кстати имя всегда свзано с некоторой реакцией, и возможностью быстрого распознания объекта, а также возможностью поиска, создает уникальность данного объекта в пределах некоторой адресной книги 
кроме того имя отражает цель (хотя серега вряд ли отражает цель), хотя слово "индекс" всегда используется для обозначения "номера порядка в списке", но использование одного имени иногда невозможно
(например встрроенные циклы тогда это будет индекс1  и индекс2) также слогаемое (1,2,3..)
по имени можно найти сам объект, а также его описание 

Словарь можно составить еще с инксным файлом( это пара (имя, адрес)) , адрес этой пары в списке может меняться, но адрес нет, т.е. пара перемещается всегда целиком (если пара сохраняется в Хранилище у нее всегда есть уникальный адрес) и проблем нет
если это просто группа, то удаление некоторой пары, будет вызывать смещение, будут меняться номера пар, и тогда нельзя использовать номер пары как уникальное имя.
Можно создать индексный файл абсолютный адрес, он никогда не меняется и не удаляется,который имеет ссылку на номер в группе (куче) в куче можно удалять объекты
т.е. номер в индеске играет роль уникального имени. Здесь будут адреса которые будут указывать на нулевой индекс, что значит, что он удален. Это экономит память. 
Хотя удаленные пары можно не удалять, а обнулять(нет имени, нет значения) при просмотре в цикле они просто пропускаются 
(это хуже поскольку каждый раз в цикле придется проверять на ноль, хотя там нет ни одного удаленного объекта, хотя с индексным файлом тоже придется каждый проверять

	Основные операции с объектами
	Копирование- создание новых объектов 
клонирование - создание точной копии независимой от другой старой, создаются даже новые строки, 
копирование - создание копии с незаполненными переменными, в цифре копируется описание объекта (имя= цифра) , но значение остается пустым 
создание нового экземпляра типа копируется - только структура, в поле Имя копируется адрес существующей строки, поле Значения не копируется 
так копируется тип, экземпляр типа
Т.о. можно выделить несколько каждое поле нужно пометить как оно копируется, копируется значение (значение адрес и число), копируется только 
в сШарпе в поле определения может стоять команда задания значения ( = new List { список значений}) 

	Копирование в другое адресное пространство (Хранилище)
копируется путем создания аналогичного типа объекта вместе со значением, без значения. когда копируется строка в другое хранилище. копируется вместе со значением. После получения копии, происходит
распознание объекта, т.е. ищется адрес слова вставленного в переменную строки, както ищутся более сложные объекты, ищется словарь букв,
 после чего старый адрес заменяется существующим или сущ. словарь дополняется
 копирование в другое хранилище отличается от копирования внутри, при переносе копии могут передаваться целые словари, так слово часть словаря и подобный словарь нужно создать и в другом хранилище,
 единственно, создается пустой словарь 
 Еще вариант копирования может быть неполныйм, потому что нужна только часть информации, тогда копируется основная структура, а значения указываются как адреса в другом хранилище, по мере надобности эти
 значения скачиваются из источника и либо распознаются, либо временно используются, значения не копируется (удаленный объект)
Неполное копирование всегда имеет поле родитель с адресом объекта для возможности получения информации. Простеший вариант переноса передача одного адреса удаленного объекта, потом получается имя типа
потом копируется словарь с именами, потом типы, потом значения, если значения адреса( объекты), процедура может повториться  
адреса слов из словаря должны иметь два адреса, адрес словаря и порядковый номер в словаре, можно и просто адрес слова в хранилище, но тогда слово должно иметь ссылку на свой словарь (двустороняя связь)



связи  одновременно могут отражать структуру связей ("следущий" в связяном списке ) или 
отношения реальных объектов "собака" "имеет" "хвост". Реальные отношения могут быть реализованы разными структурами. Эти структуры должны быть доступны, модифицируемы, заменяемы
Однако действия с реальными объектами должны быть одинаковыми. 


Операции с действими

Копирование методов
	Методы в процессе выполнения могут модифицироваться, упрощаться, но ссылка на первоначальный метод должна сохраняться
	модификация: замена поиска по имени на точный адрес объекта, берется Действие (присвоить перемееной с именем "" значение) меняетя на Присвоить(переменной номер значение)
действию всегда передается адрес некоторого объекта словаря например, где действие может черпать нужные данные
в функцию передается список или словарь параметров (+ список внутренних переменных иногда, там может быть конфликт имен, если их тупо складывать, 2 "индекс"а например, (если имя содержит еще и имя словаря нет проблем)
в метод объекта список параметоров и адрес экземпляра + список внутренних переменных
в цикл передается словарь или список внутренних переменных последовательности

каждое действие из списка туда передаются требуемые списки, запускается действие на выплнение, действие что-то вычисляет, меняет, возвращает некоторые данные
возможна проблема зацикливания, т.о. действие захватывает процессор и предыдущее действие-последовательность забывается, чтобы этого не было проще создать новый процессор и отдать ему рецепт, а
действующий процессор будет контролировать этот процессор и если нужно прерывать его. также новому процессору можно выделить отдельный объект память- словарь где будут сохраняться текущие переменные
память будет ограничена по объему, на случай переполнения, размер этой памяти может регулироваться ведущим процессом, по запросу исходя из анализа 
передав управление новому процессу, ведущий засекает время выполнения, расход памяти и других ресурсов, эта функция может отключаьтся для стандартных отлаженных действий.
	Безопасность
Окружение передаваемое процессору передается с разрешениями, что-то можно менять, что-то только читать, это опять чтобы не испортить данные.
Самый безопасный вариант передавать только точные копии окружения, а потом результаты распозновать (встривать в существующее окружение)
Другой вариант безопасности, анализировать код перед его выполнением, как правило заранее можно просчитать его воздействие на окружение, потребляемые ресурсы, возможные проблемы (исключения), сбои, и т.д
можно провести оценку времени О(н) сзная среднее количество букв в слове и величину словаря можно подсчитать время поиска в словаре
можно посмотреть какие файлы предполагется открывать, какая информация будет использоваться и что с ней будет делаться, будет меняться степень секретности информации или нет 

Расширение действий :
чтобы не менять само действие нужно ввести именовванные блоки кода, например проверки, чтобы можно было добавлять, удалять проверки, допустим запустился код и вызвал ошибку "адрес пуст", нужно вставить
проверку на пустоту и если это допустимо перейти к другой части кода или обработать эту ситуацию иным образом 
Нечеткие действия, например сейчас "вставить проверку на пустоту" вставить куда?, когда?, почему появилась "пустота"?- оценка предыдущих действий

программа запуска действия:
	передать дейставию окружение
	началоЗапуска = текущее время = засечь текущее время
	создать память для действия
	действие.память = новая память
	создать новый процессор, передать ему действие (возможно, память нужно передать процессору)
	запустить процессор
	перейти в состояние контроля выполнения
	если процесс заершен, получить результат
	посчитать затраченное время и другие ресурсы (память, время использования сети, трафик сети, трафик диска, т.е. использование служб и людей(пользователей) )
	распознание результата:
	если результат - это ошибка, запустить процесс оценки ошибки, если рецепты оценки есть, 
			если нет действие отбраковывается, запоминается ситуация, в списке действий помечается как "ошибочное" или удаляется
			или предлагается перейти к отладке пользователем
	если ошибки нет, то
	сравнить результат с ожиданием, например сравнить полученный тип с ожидаемым типом, проверить качество
	если результат устраивает закончить, 
	
программа выполнения последовательности действий
имеем список внутренних переменных
список выполняемых действий
цель: выполнить последовательно все действия
	  если возникнет ошибка остановить выполнение, запомнить ошибочное действие
	  либо попробовать продолжить выполнение, возможно ошибка не критичная, если и дальше идут ошибки, прервать выполнение
	  в реудьтат записать информацию об ошибке
	  Возможные ошибки 1. не удалось найти переменную (объект), например соль, послать запрос "дай соль или аналог или дай действие "где взять" или "где брать впредь" "
		эмитация действий: например добавить соль, переменная окружения соль есть, кастрюля.содержимое.добавить(что=соль, сколько=10гр)= содержимое.объем+объем соли, сравнить объем кастрюли и содержимого
		 результат "отчет:готово" если сколько не заполнено, то возникнет нечеткое количиство и содержимое+=порция_соли.количество это не цифра а адрес параметра, что не складывается, добавляется в пропуще
		эмитация объектов: соль(количество =100 гр, где находиться = салонка), перечень свойств может быть не полным, где находиться в предыдущем действии не нужно. "Как" добавить действие не содержит
		куда= кастрюля.содержимое , добавление меняет только объект содержимое кострюли
		отсутствие значения "как" у "добавить" = "не важно" предположение что это выполнимо
		если добавить "автомобиль" то возникнет ошибка, из-за размера, не исправимая ошибка, последовательность прервется, запомниться текущее действие 
		или пропуститься, возможно это просто ошибка случайная 





Связи дороги
	закальцованность дороги, хождение по кругу, хождение по одним и тем же дороггам - отсутствие новизны, с другой стороны, формирование памяти, эффективность, быстродействие
	переключение внимание, вариативность, плохая память, не эффективность, относительная новизна
 один и тот же объект может иметь разную структуру, например группа пар(ключ, значение)= пара групп (ключ)(значение), способ доступа к данным разный, второй быстрее для поиска ключа( меньше действий)
 второй вариант похож на таблицу, добавление нового поля(столбца), создает это поле у всех объектов (строк), способ расширения, ввести столбец с адресом расширения 
 отдельно, ключ и значение никак не связаны с таблицей, значит трудность доступа к описанию, можно конечно выделять из таблицы объект вместе с описанием, создавать новую именванную пару, объект типа
 в SQL делается выборка в виде новой таблицы (опять описание отдельно в свойствах таблицы)
 экземпляр типа это тоже отдельная строка (группа значений (или адресов))+ адрес на описание таблицы.

 но набор команд одинаковый найтиЗначениеПоКлючу, найти номерПары, добавить пару, удалить пару. Т.е. черный ящик реализации (как?), внешне (интерфейс) выглядит одинаково,но скорость разная

 Связи Меня смущает выделение и главное именование связей (имеет (как часть, в собственности), является экземпляром (это),является частью, относиться к, связан как-то)
 кажется что все связи  выражаются шаблонами и это имена шаблонов иногда разные, одного и того же шаблона, 
 Так типы получаются путем группировки схожих объектов, имеющих одну структуру, схожее взаимодействие, одинаковый интерфейс (набор имен)
 Создание группы (группа - множество (без повторов)=словарь,группа однотипных частиц (график), группа разнотипных частиц (предложение) )
 объекты в группу могут попасть только по одному схожему признаку или по множеству, ОТСЮДА можно посчитать степень схожести. В тип попадают объекты с одинаковыми именами полей и их типами (описаниями)
 Поэтому изнчально нужно создать объекты с полным самоописанием и только потом их классифицировать
 Сами объекты появляются в результате распознования, разделения на группы, сортировки, выявлении иерархии, часть подгрупп называются потом частями если они всегда присутствуют в другой группе и не отделяются 
 или могут отделяться (есть части тела и есть части машины) Есть представление, что все объекты, состоят из разделяемых частей, частиц, которые как-то связаны (сильно, слабо, не связаны),
 если объекты не связаны, то это разные объекты, 
 Есть еще и группы действий, последовательность изменений во времени, эти изменения тоже группируются и именуются, (мячик скачет = нужно запомнить несколько раз одно и тоже)
 
 Наслаивающиеся реакции- приход сигнала в глаза преобразуется в действия.(Видишь сладкое - хочется пойти поесть- это преобразование) 

 
 Как изобразить линейную программу при помощи активностей?
 повторяющийся ряд - это цикл -это колебание

 реализация кармического программирования
	отдача команды- получить результат
	поискать результат в словаре, может быть найдено несколько вариантов,но не все буквы будут найдены, 
	результат либо спросить, либо попытаться эти буквы дополнить=вычислить= найти функцию, но параметры известны не все, попытаться найти параметры
	результатом может быть команда, но может быть и описание ситуации (файл не найден например)тогда ищется вариант реакции, ищется причина почему не найден, кто дал команду и почему?
	если результат найден, то выполняется следущая команда
	как правило результат= "выполнено=готово" это краткий ответ, затем можно "возьми объект в ячейке Результат" "смотрите по адресу" - 
	хотя команда может быть "выполнить что-то и поместить результат в какую нибудь переменную", тогда ответ "готово" достаточен.
	если результат = "ошибка"+ описание где, какая ошибка, то остановка выполнения, 
		1 вариант: устранить ошибку и повторить команду (возможно связь оборвалась), найти правильное имя файла или поискать в другой директории, вспомнить откуда взялось это имя ит.д.
		2 вариант: подождать и повторить (простейший вариант) возможно ошибка синхронизации, некоторые требуемые внешние параметры не приняли требуемое значение, "служба не отвечает", "данные еще не скачались"
		3 вариант : остановить выполнение и вернуть свою ошибку- переложить принятие решения на вышестояющую команду, пусть она ищет причину, возможно нужно изменить параметры этой команды и запустить ее вновь
		4 вариант: откатить выполнение на несколько шагов назад (если это возможно), изменить часть параметров, 
		эти варианты можно поделить на две группы 
			1.попытаться устранить самому, 
			2. отказаться от выполнения, 
			3.попросить помощи у кого-нибудь. = получить список инструкций (как сделать?), нужных данных, готовый результат
			4 ждать пока само пройдет. (эта целая категория событий, возможно "ошибка вида= пожди делаю, обращайся через 10 секунд") в памяти должны быть уже похожие ситуации.
				Реализуется циклом (замкнутым графом, выход по условию)

		исполнение программы надо как-то запоминать, типа вести лог=историю, там можно искать варианты устранения ошибок, если ошибки повторяются - корректировать работу, чтобы они не возникали, 
		или были минимальными. лог это я что-то когда-то сделал и был успешный, неупешный результат


		для некоторых действий, бесполезно ждать для повторения, результат будет тотже

	действия бывают запрещенные, спрыгнуть с большой высоты, отформатировать диск, удалить важный файл 
	результат разных действий можно заранее описать "все файлы будут потеряны", можно скопировать данные и все равно запустить
	либо просто запретить или всем или части обращенцев, если всем то единственный вариант сущность разрушить. 
	"страх" выполнение грозит наказанием, бояться наказания - шаблон поведения будет нарушен, что приносит не удовольствие, ограничение или лишение доступа к ресурсам.

	при создании программы сначала ее надо протестировать на ограниченном блоке данных, создается как-бы черный ящик, мы ожидаем один результат, а может быть другой, 
	поэтому сначала мы создаем модель поведения, в виде набора примеров (например список тестов), пример может быть и условием, было столько денег стало больше на 20%
	выходной результат это ожидание, ожидание это открытый шаблон, шаблон проверки это ожидание некоторого символа, оно же условие, которое дает да или нет, 
	сложить(2 и 2) результат =4
	торгуй(100 руб, 1 год) результат >120 руб

	

		число всегда связано с его получением иили присвоением, кто-то дай число по адресу, как он сохранено неважно. т.е. все числа всегда являются свойствами С№
		однако его всегда надо както хранить
		но к каждому объекту должны быть определенные команды, типа: дай значение, дай описание (что это?) (струтура= (список (элементы),множество , объект, тип объекта )) 
		поэтапное считывание, похоже на поочередные запросы к объекту (GetType) и потом уже более детальный разбор, только в Type очень запутанное описание, в XML все получше больше снандартизовано
		расширение переменной от просто имени, типом, должно постепенно добавлять методы связанные с новой информацией

		создатьПеременную ( словарь, имя)
			найти имя в словаре
			если не найдено, то добавить в словарь имя
			если найдено, сообщить что имя уже существует
		создатьПеременнуюСтипом (словарь, имя, тип)
			найти имя в словаре
			если не найдено, то добавить в словарь пару( имя, тип) или добавить в словарь имя, к перемеенной имя , добавить переменную тип, т.е. объект имеет имя (значение), имеет тип (значение)
			если найдено, сообщить что имя уже существует
		присвоитьЗначениеПеременной(словарь, имя, значение) - 2 варианта, переменная имеет тип или не имеет
			найти переменную адрес в словаре по имени
				//это часть относиться к расширению перемееной "имеет тип"
				узнать имеет переменная тип, если имеет, то
					узнать значение типа переменной
					узнать тип значения, если значение имеет тип
					сравнить эти два типа, если совпадают, то перейти к записи
						если нет, сообщить об ошибке несовпадения типов
			записать значение по адресу

		Этот метод не знает есть у перемееной какие-то атрибуты или нет, т.е. он должен сначала найти переменную, а затем запустить свзяанные с атрибутами методы
		к атрибуту "тип" должна быть привязан метод "присвоитьЗначениеПеременной" а точнее сравнение типов двух значений атрибутов.
		Видно что паралельно нужно узнать узнать имеет перемееная и значение атрибут "тип", если значение не имеет атрибут "тип" и переменная не имеет "тип", то пропускаем сравнение типов
		если переменная имеет тип, а значение нет, отказ в присвоении
		если переменая не имеет тип, а значение имеет, перейти к присвоению (либо отказ в присвоении)
		если оба имеют тип, то перейти к сравнению типов,

		значение выше это объект, который не имеет атрибут имя, но имеет атрибут значение, и может иметь другие атрибуты (тип, доступ и т.д.)
		т.о. в словарь добавляется этот объект и ему добавляется атрибут имя, либо существут 2 объекта, переменная с атрибутом имя и адресом безымянного объекта
		в словаре существует список именованных (и типизированных) адресов (перемееная)
		В цикле мы создаем одну имеованую переменную с именем "поле,элемент" и последвательно приваиваем ей, элементы списка, т.е. имя присвивается только текущему элементу списка, остальные типа безымянные
			если все элменты имеют один тип, то проверка типа может пропускаться

			Итак, переменная это цепочка активностей по передаче сигнала, 
			1. распозноание имени 
			2. сравнение типа - распознание типа (тип может быть четким а может быть нечетким , не все буквы должны совпадать)
			3. запоминание адреса, присвоение значения адреса
			в начало этой цепочки подается например адрес или команда текстовая, которая разбирается и возможно по дороге усекается, отщипываются кусочки
			если в переменной нет сравнения типов, то переходим сразу к запоминанию адреса

			словарь ищет имя активности, куда передает адрес для запоминания, т.е. простейшая активность это тупое запоминание адреса или числа
			т.о. команда "присвоитьЗначениеПеременной(словарь, имя, адресЗначение)"= словарь.Получи(имя, передай адрес/значение)=
			= (словарь) переменной (имя) присвоить (адресИлиЗначение)
			Команда "создатьПеременнуюСтипом (словарь, имя, тип)"=
			словарь создай переменную (имя) имеющая тип (имяТипа)- это создание цепочки активностей - найди- список букв - сравнение типа -запомни- переменная(запоминание чего угодно)
			Команда: Словарь(дай значение переменной (имя)) тут цепочка - (найди- имя) - (дай)- переменная) //отсутвует в этой цепочке сравнение типов 
			имена команд могут быть представлены как отдельные активности связывающие одни и теже активности (имя - значение-переменная)
			получив адрес активности, получаешь список связанных активностей. так у переменной - это (дай, запомни), запомни - сравнение типа (это же просто тип)- дальше имя (если создана двустороняя связь)


			другой способ представления КОМАНДЫ

			(субъект=словарь) (команда=присвоить) кому=переменной (имя), что= Значение (адрес)

			распознаем так команду и начитнаем поиск словаря, потом, команды, потом переменной по имен, потом присваем значение
			если значение содержит команду то возможно параллеьное вычисление (найди словарь)- вычислить переменную, однако если такой переменной нет, вычисление будет лишнее

			
			 
связь это простейшая активность которая содержит 2 метода "получи" и "дай"
независмые активности т.е. те что имеют собственный процессор, имеют адрес некоторого буфера из которого они забирают информацию, или помещают туда информацию
все равно надо както различать входящие и исходящие связи
входящие связи это любая активность которой известен адрес данной активности.ПолучиСообщение() может содержать обратный адрес активности. Этот адрес может запоминаться а списке исходящих, 
а может и сразу забываться.  Никакого контроля доступа в такой активности нет. Типизирование это контроль доступа, активность запоминает адрес типа, получает этот адрес как пароль, Т.е. есть общий знакомый
и уже тогда продолжает что-то делать.

Это реализуется выше как создание входящего посредника для активности-переменной, т.е. переменная доступна только своему посреднику - это и получается связь, которая в данном случае имеет адрес типа
и соответсенно имя этого типа. Наличие такого типа посредника у перемееной означает что переменная "имеет" данный тип, "является" "строкой" "числом" и т.д.


Волна превращается в частицу в момент измерения. Волна это характеристика множества частиц. Частица это локализация в точке. Т.е. процесс измерения (столкновения с другими частицами) проявляет волну
это похоже на группировку (концепцию) множества объектов в один объект 

Сделать
1.фабрика объектов - это типа магазина, где можно создовать новые объекты - это известная форма по созданию объектов из типов хранящихся в сборках
2. хранилище на диске - объекты храняться только на диске, чтобы что-то с ними сделать их загружают в память, преобразовывают и снова записывают на диск, должна быть частичное загрузка в память
3. распределеннок хранилище - множество файлов (потоков данных) данные имеют еще метку байтовую, типа счетчик, которая сохраняется после записи на диск объекта, при считывании метки сравниваются, если был сбой
берется объект с большей меткой, если файлов много они обходятся по очереди, сначала можно взять 1 источник и последний, если метки совпадают, завершить чтение




DВсе объекты можно сделать из активностей, котороые состоят из ядра и связей. Связи это тоже можно сделать активностью, только усеченной, имеет только 2 адреса, прямой и обратный

все активность должны быть динамическими, т.е. их постоянство зависит от повторяющехося процесса, если процесс останавливается - останавливается обмен сообщениями со связанными объектами, активность умирает- исчезает
ее становиться не видно (черная материя) В компе память это физический процесс сохранения значения цифр. 
Пространство это изначальная активность, которая не имеет ограничений по связям, связана с соседними активносями-пространства, в 3-х мерном пространстве это аналог сота - 8-гранника, какой нимудь додекаедр
т.е. в 2-хмерном пространстве элемент пространства имеет 8 связей = числу граней. Пространство может иметь и иное количество связей и не только с соседями, тогда сообщения могут скакать в пространстве (тунелировать).

	Свет переносчик взаимодействий- сообщений - широковещательных. фотон- адресное сообщение, виртуальные фотоны -безадресное. Полоуччать сообщения могут только другие частицы имеющие электронный заряд (протоны) 
фотонное иртуальное поле можно просто считать = пространственному полю, с особыми сообщениями. Сила соообщения падает по мере удаления от источника. 
Электрон непрерывно посылает сообщения в пространство, создавая электрическое поле. Размер сообщения падает обратно пропорционально растоянию до него. каждая точка пространства делит сообщение на 8-частей 
и передает соседям, сосед от которого пришло сообщение обратно ничего не получает. элемент пространства за цикл может получить 8 сообщений, которые складывает, потом делит на 8 посылает соседям 
	Электрон это модифицированный элемент пространства, который постоянно шлет сообщения, Атом это тоже тоже модифицированный элемент - объединяющий электрон и протон. Это элемент группирования обмена сообщениями,
	все сообщения идут только через него, поэтому враение электрона не дает излучения нет потери энергии

	Память долговременная  это список отсортированных данных
	кратковременная список не сортированных (список короткий) можно искать быстро
	слова можно хранить как список (отсртированных букв) одному значению может ссотвествовать большое количество слов, но уже значительно меньшее 
	вопрос как оследить слишиеся слова или лишние пробелы
	Лучше всетаки разбивать поток букв на тройки так проще самообучение 
	как распознование слов связано с процедурой поиска решения - алгоритм должен быть один

	функция это запуск некоторого исполнения после получения всех параметров + дополнительной команды выполнить (это не обязательно) (эта доп команда средство контороля со стороны фокуса)
	Фокус может запустить и не полную функцию (некоторые параметры могут быть не определены) - аналог силы воли 
	без силы воли функция становиться автоматом - независмо существующей структурой. Такая функция должна обладать собственным процессором или пользоваться процессором последнего аргумента
	эта часть активности логического И (каждый аргумент посылает сообщение о готовности - они суммируются -превышение порога- запуск )

	последовательность действий активность запускает последовательно другие активности - передает сообщения и получает ответ 
	создать переменную = создать временную активность и запомнить ее адрес для дальнейшего обращения
	присвоить значение переменной  = передать перемееной значение
	вызвать функцию (например сложение) = найти функцию по имени, передать ей параметры , получить значение (возможно создать новую времееную активность, чтобы другие активности не пересекались)
	вернуть результат отправить значение вызвавшему или списку подписанотов
	удалить временные активности или вернуть их в пул (на склад) ддля повторного использования. склад  это доп издержки, на поиск, но и возможность скачивания удаленного кода 
	использование разных экземляров последовательности позволяет решить вопрос многопоточности сохраняется текущее состояние вычислений 


	есть вариант когда до начала выполнения создаются все активности-переменные и активности-функции связываются и затем запускается последовательность 
	если перемееная используется несколько раз 1 шаг прписвить значение1 2шаг присвить знач2 - активность владелец последовательно передает два сообщения 
	все ссобщения идут через владеьца он посылает сообщения, получает ответ , ответ отправляет следующей активности 
	активность сложение работает так: владелец посылает ей сообщение в которой передает или точное значение или адрес, чложение получает адрес считывает значение,опрация, возврат
			или владелец вместо передачи адреса получает значение из переменной и передает два значения (возможны оба варианта 1 случай опасен для паралнльных вычислений )
			передача адреса вместо значения означает разделение ресурсов между активностями 
			передача только значений позволяет держать одного вычислителя, который обслуживает много активностей одновременно т.е. использовать внешнюю постоянную активность (невремеенную)
		операций сложения много ии создавь такое же количество временных активностей накладно 
		Активность без процессора это просто рецепт , который эмулирует работу активности с отсылкой-получением собщений (возможны накрасходы на создание сообщений)

	Основная идея существование постоянных переменных как ячеек таблицы, которые вычислятся как процесс горения 

	Мат формула это всегда линейная передача данных т.е. если переменная используется, то она не меняется и ее ситывание несколько раз безопасно 

	Владелец последовательность может неполучать результат вычисления, а перенапрвить его сразу по адресу в переменную ответ от вычисления все равно будет что выполнено, чтобы последовательность продолжилась
	Варант передал и перешел (и забыл) к следующей операции в последовательности паралелит выполнение последовательности и требует наличие собственного процессора у вычислителя - это уже другое програм-е
	Есть вариант передал и ждешь ответа а пока ждешь делаешь что-то еще, приход ответа прерывает текущую деятельность (как непонятно ??) заканчиваешь текущую операцию и переходишь к обработке соощения
		т.е. после каждой операции необходимо проверять входящие сообщения, после обноручжения надо запомнить место прерывания и после обраблтки собщения вернуться и продолжить 
		В обычном програмировании чужой активности разрешается считывать твой код и выполнять его за тебя , используя твои внутренние переменные (что не безопасно)

		КОПИРОВАНИЕ Объектов
		проблема с копированием адреса. Если создать новый объект с адресом, то он будет указывать на объект который тоже надо размножить, т.е. сначала надо получить объект, сделать копию, создать новую
		ссылку на копию объекта. Другой вариант сделать копии ссылок, пометить что объекты по ссылкам не клонированы и вторым проходом клонировать с заменой.
		Группа может содержать два одинаковых адреса и придется клонировать объект дважды, хотя первоначально он один. 
		Придется сделать таблицу где запоминать адрес старого объекта и новый адрес его клона.
		Проблема взаимных ссылок группа1 имеет адрес группы2, группа2 адрес группы3, группа3 адрес группы1 - появляется цикл если делать все методом рекурсии 
		в команду 

	Копировать( адресаУжеКлонированных старых объектов Список ) // для удаленных объектов кидать друг другу такой список или даже адрес такого списка накладно , владелец списка начало клонирования
												// Список содержит старые и новые адреса всех групп
		если (Список == пусто) создать новый список (старый, новый)
		Группа1 записывает свой старый адрес в Список, строка = новый массив(рамер =2), строка(0) = старыйАдрес
		группа12 = создать новую группу // в каком адресном пространстве не понятно
		новыйАдрес = зарегистрировать группу2 в адресном пространстве
		//к старому адресу в списке сопоставить новый адрес
		строка(1) = новый адрес
		для (и=0 до длины группы)		
				старыйОбъект = Группа1 (и)
				если старый объект это адрес, то // если адрес из другой группы (Хранилище)(это независимый объект) можно заменить не на адрес, а на сам объект вкючив его в новую группу
												 // важно совпадают адресные простраства клона и копируемого объекта или нет 
												 // справочник слов например клонировать не надо, если клонирование происходит внутри одного Хранилища 
												 / указать что копируется (адрес объекта содержит откуда), откуда(Адрес) и куда(адрес)
												 /копировать независимый объект или нет Как решить??
												 / копирование списка слов , копируются адреса слов,которые содержаться в словаре слов (адрес словаря,адрес слова )
												 / вариант 1 скопировать весь словарь (если отедльно храниться адрес словаря, и адреса слов относительные оставить прежними)
												 / вариант 2 создать новый подсловарь только из тех слов что копирутся 
												 / 3 взять объекты по указанному адрес слово=(группа букв+ адрес кодовой таблицы)
												 / 4 целевое адресное пространство тоже - копируются только адреса
					найти (старый объект в Списке)
					если старый объект найден, то 
						новый адрес =Список(старый объект).Копировать() // это адрес
					иначе
						если объект по старому адресу это группа
						то
							если целевое пространство == исходному,
							то
						иначе
							
						добавить старый объект в список // все адреса добавляются чтобы чтобы не клонировать один и тоже объект дважды , здесь сами объекты не клон-тся, клон-ся только адреса
														/ здесь этакоманда не нужна
					
				иначе
				если старый объект это группа, то
					новый объект = старыйОбъект.Копировать(Список) //Список передается только группам
				иначее
					новый объект = старыйОбъект.Копировать() 

				Группа12(и)=новый объект
		конец для
	конец Копировать

	Группа может содержать огромные справочники или уже скопированные объекты которые клонировать не нужно, тогда надо или сохранить удаленную ссылку, или попытаться найти в своем адресном пространстве или ближайшем,
		или скопировать в свое адресное пространство 


		 Должны быть минимальные правила и универсальные методы и правила, независимые от формата реализации для создания обучаемой системы

Первая активность это общедоступная активность черерз которую можно получить частный доступ к группе других активностей - это похоже на создание переменных 
	все что она делает получает сообщения, создает частную активность куда копирует исходящие связи, т.обраозом к группе активностей получает доступ сразу несколько удаленных активностей. 
	команды: ДайЧастнуюАктивность(тип активности)= ДайСвязь(обратный адрес) = 
		создать новую активность с входящей связью(которая имеет удаленный адрес = обратной связи), (активность может быть и водельном процессе и на другом компе )
		отослать обратно адрес новой связи-активности 

ПРимитивная Активность имеет одну входящую одностороннюю связь и хранит значение одного примитва
	имеет команды: ДайОбъект
					НаОбъект
					ДайОписаниеТипа, - это словарь (простешее это имя или номер в словаре , Уникальный можно сюдаже)
					длина в байтах
					ДайУникальныйНомер (hash)- может пригодиться если по вдресу активности окажется постороння активность 
					ДайИмя 

		это можетбыть и группа, но записывается и читается она целиком - это аналог передачи по значению
		Активность может самоликвидироваться после окончания связи (обрыва) как переменная в методе , либо создавшая ее активность может ликвидировать 


Примитивная многопользоватеоьсяка активность - имеет несколько пассивных входящих связей, 
				пока одна связь имеет доступ к примитиву, другая блокируется - это для записи
				для чтения нет блокировок, но пока чтение незакончено, записиывать нельзя
				Командыд доп: ДайКоличествоСвязей (действующих и спящих)
							 Установить/Снять МонпольныйРежим = блокировать другие связи - опасно связь может оборваться, а блокировка останентся, по обрыву связи блок снимается (таймер сложно )
				
			Разновидность этой активности несимметричность для разных связей, кому-то только чтение, кому-то разрешена запись (например датчик температуры или права администратор)

Дальше активность с активной исходящей связью , хотя серверные входящие связи двусторонние по ним отсылается обратно информация, но исходящие здесь пассивны (женские)

команды дополнительные: СообщиОбИзменении (однократно, всеизменения, порасписанию, по переданному сценарию) - это создается  обратная связь активное исходящее (или двустороння связь становиться активной )

 "Слогаемое" это имя параметра, это функциональное существительное (отглагольное существительное) (Типа покупатель, деталь) Сама активность имеет другой имя (может быть результатом вычисления ) 
 "Сумма" это имя результата действия - результативное существительное (Покупка - то что было куплено Яблоко например) 
 "Яблоко" - распозноваемое существительное (имя образа) ярлык "Покупка" требует знания истории, не может быть определено в результате распознования (изучения внешней структуры например)



	 





  






