using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Динамические
{
    //Связь это разновидность Активности с одним входом и одним выходом 
    // Активность это группа ( регистратор более общо)
    // Связь должна самонастраиваться, если  это чистый клиент, серверную часть можно убрать
    // Если связь чисто локальная и синхронная, то  нужно сразу вызывать метод активности
    // если пррывание каналом не поддерживаетсяя то часть кода наверно тоже можно выбросить
    public class Связь: РАМОбъект
    {
        public Канал Канал;

        public Активность РоднаяАктивность;
        public РАМОбъект ОбслуживаемыйПРимитив; // это может быть и активность родная 
        public Адрес АдресСобственный;
        private Адрес _адресУдаленнойСвязи;
        public Адрес АдресУдаленнойСвязи
        {
            get { return _адресУдаленнойСвязи; }
            set
            {
                _адресУдаленнойСвязи = value;
                var типКанала = value.ТипКанала();
                if (Канал != null)
                {
                    Канал = (Канал) типКанала.GetConstructor(Type.EmptyTypes).Invoke(null);
                }
            }
        } // точнее связи
        public Активность АктивностьУдаленная; // это для редактирования в редакторе, как будто они в одной памяти минуя связь в удалкенной активности 
        public Активность ОбразУдаленнойАКтивности; // может содержать список поддерживаемых команд , тип, имя - позволит вернуться к первоначальному варианту где сообщения отправяляются в активность

        public string РольУдаленного; // Поставщик, Заказчик, 
        public string Права;
        public bool ПравоНаОтдачуКоманд;
        // право ползьзоваться = право отдавать команды и получать результаты выполнения
        // право распоряжаться - право отдавать исключительное право отдавать команды
        // право владения - хранение
        // аренда - право на временное  исключительное пользования

        // для заказчика: создавать новый объект, менять значение объекта (писать), удалять объект, получать значение объекта(читать), давать команды,
        // для подрядчика: выполнять команды (встроенные, сторонние), 
        

        public string ТипСвязи; // входящая, исходящая, двустороняя и т.д.

        //public bool Активная; //сервер - клиент- и то и другое 
        //public string Инициатива;
        public bool ЯвляетсяСервером; // значит зарегестрирован в некотрой другой активности и ждет от нее сообщения  (все объекты С№ являются серверами) = ОЖИДАЕТ по адресу у Диспетчера
                            //создание клиента это открытие сеанса связи с удаленной активностью через посредника 
                            // 
        public bool ЯвляетсяКлиентом;
        public bool МожетПолучатьСообщения; // если нет часть функций отключаться, если он сервер, то после установки соединения, сразу отправится сообщение
        public bool МожетПередаватьСообщения;
        // может быть целая куча вариантов других, подписка раз в секунду передавать данные, передать данные а потом только изменения


        public bool СохранятьСвязь; // сразу закрыть , сохранять сеанс, другие сценарии (сохранять некоторое время), что делать если не удалось доставить
        public int ВремяЖизниСвязиБезСоединения; // если последнее время соединения больше этого промежутка связь удаляется 
        //где закладывать эту самоликвидацию, здесь, или в активности???
        
        // роль связи - Удаленный объект является, заказчиком, подрядчиком (поставщиком информации)

        public string ИмяСвязи; // оописание связи ( у активности Буква будет связь с "а" имяСвязи= " мой экземпляр" обратно ИмяСвязи="относиться к типу"="является"="это"
                                // имя связи это характеристика обмена сообщениями - это разные протоколы общения 
                                // "является" = относиться к группе имеет ссылку на объект группы
                                // "имеет" = имеет адрес активности, которую может менять, создавать, уничтожать, кого "имеют" такой возможностью не обладают, = имеет возможность отдавать команды
                                // команда это последовательность действий : инициатор передает сообщение, реципиент получает, реципиент обрбатывает сообщение, дает ответ инциатору, переходит в состояние ожидания нового сообщения
                                // обмен сообщениями более общий протокол : есть вариант послал и забыл

        private Thread СобственныйПоток;


        //private Действие СписокДействийСторонний; // программируемая связь если протокол  еще не согласован
        private string состояние = "старт";
        private string состояниеПриема = "с";

        //эти переменные нужны только для связей поддерживающие опросы 
        public int ИнтервалОпросаВходящих = 10;
        private int ВремяОжиданияПриема;

        private Action РеакцияНаОшибкуСообщениеНеКоманда; // если сообщение не в формате команды
        public Action МетодПриемаСообщения;
        public Action СигналОПоступленииСообщения; //Прерывание ожидания из канала
        private string событие;
        

        public Связь()
        {
            РеакцияНаОшибкуСообщениеНеКоманда = РеакцияНаОшибкуФорматаСообщенияПовтор;
            МетодПриемаСообщения = Прием;
            СигналОПоступленииСообщения = ОбработкаСигналаОтКанала; // это использование чужого потока

        }

        public virtual void Старт() // вся логика подходит для разных типов связи,точнее каналов связи стоит перевести ее в оПисание связи, здесь оставить только Регистрацию, Устанвить связь, Стоп
        {
            if (ЯвляетсяСервером) // это также нужно если используется ассинхронная передача данных с активностью
            {
                состояние = "старт";
                СобственныйПоток = new Thread(ПереключениеСостоянийСервер); // это обработка входящих
                СобственныйПоток.Start();
            }
        }

        
        // это похоже на словарь где элементы методы
        public void ПереключениеСостоянийСервер() // это полностью блокирует поток пока не дойдешь до выхода 
        {
            while (true)
            {
                switch (состояние)
                {
                    case "старт": Начало(); break;
                    case "ожидание подключений": ЦиклОжиданияПодключений(); break;
                        // ниже это отвлечение вход в новый бесконечный цикл
                    case "обработка входящих сообщений": состояниеПриема = "ожидание приема"; ЦиклОбработкиВходящих(); break;

                    case "окончание сеанса": состояние = "ожидание подключений"; break;
                    case "обрыв сеанса": состояние = "ожидание подключений"; break; // надо проверить состояние регистрации т.е. надо запустить типа Начало()


                    case "выход": Стоп(); return;
                }
            }
        }

        public void Начало()
        {
            if (ЯвляетсяСервером)
            {
                Канал.Регистрация();
                if (ЯвляетсяКлиентом)
                {
                    Канал.УстановитьСвязь();
                    if (Канал.СоединениеУстановлено == false)
                    {
                        состояние = "ожидание подключений";
                        //и или
                        состояние = "начать периодические попытки подключения ";
                    }
                    else
                    {
                        событие = "установлено новое соединение";
                        состояние = "обработка входящих сообщений";
                        //состояние = "восстановленно соединение";
                    }
                }
                else
                {
                    состояние = "ожидание подключений";
                }
            }
            else // значит это чистый клиент
            {
                Канал.УстановитьСвязь();
                if (Канал.СоединениеУстановлено == false)
                {
                    состояние = "начать периодические попытки подключения ";
                }
                else
                {
                    событие = "установлено новое соединение";
                    состояние = "обработка входящих сообщений";
                    //состояние = "восстановленно соединение";
                }
            }
           
        }

        public virtual void Регистрация()
        {
            if(ЯвляетсяСервером) Канал.Регистрация();
        }

        public virtual bool УстановитьСвязь()
        {
            if(ЯвляетсяКлиентом)
            return Канал.УстановитьСвязь();

            return false;
        }
        public void ЦиклОжиданияПодключений()
        {

            while (!Канал.СоединениеУстановлено) //цикл обработки подключений
            {
                Канал.ОжидатьПодключение(); // ожидание подключения поток блокируется 
                //проверка подлинности

                состояние = "обработка входящих сообщений";// 
            }
            
        }

        public void ЦиклОбработкиВходящих() // это полностью блокирует поток пока не дойдешь до выхода 
        {
            while (true)
            {
                switch (состояниеПриема)
                {
                    case "ожидание приема": ОжиданиеПриемаОпросом(); break;
                    case "начат прием сообщения": МетодПриемаСообщения(); break;
                    case "идет передача ответа":ПередачаОтвета();break;
                    case "передача сообщения": ПередачаВПотоке(); break;

                    case "переход в режим обработки входящих без ответов": break;
                    case "переход в режим обработки входящих с ответами":
                        МетодПриемаСообщения = ПрямаяПередачаВАктивностьСОтветами;
                        состояниеПриема = "начат прием сообщения"; break;

                    case "окончание сеанса": состояние = состояниеПриема; return;
                    case "обрыв сеанса": состояние = состояниеПриема; return;


                }
            }
        }

        bool ПроверитьИсходящие()
        {
            return ТекущееИсходящееСообщение != null;

        }

        void ПередачаВПотоке()
        {
            Канал.ПередайИсходящееСообщение(ТекущееИсходящееСообщение);
            ТекущееИсходящееСообщение = null;
            состояниеПриема = "ожидание приема";
        }

        public void ОжиданиеПриемаОпросом() // для сценария с таймером и собственным потоком
        {
            if (ВремяОжиданияПриема > 0)
            {
                var количествоЦиклов = ВремяОжиданияПриема / ИнтервалОпросаВходящих;
                for(var текущийЦикл = 0; текущийЦикл <= количествоЦиклов;  текущийЦикл++)
                {
                    if (ПроверитьИсходящие())
                    {
                        состояниеПриема = "передача сообщения";
                        return;
                    }
                    if (Канал.ДоступноБайт() > 0)
                    {
                        состояниеПриема = "начат прием сообщения";
                        return;
                    }
                    try
                    {
                        Thread.Sleep(ИнтервалОпросаВходящих); // блокировать поток
                    }
                    catch (ThreadInterruptedException) { }
                }
                // событие превышено время ожидания
                // перейтив в состояние "обработка события превышено время ожидания"
                состояниеПриема = "окончание сеанса";
            }
            else
            {
                while (Канал.ДоступноБайт() <= 0)
                {
                    Thread.Sleep(ИнтервалОпросаВходящих);
                    // после прывания 
                    if (ПроверитьИсходящие())
                    {
                        состояниеПриема = "передача сообщения";
                        return;
                    }
                }

                состояниеПриема = "начат прием сообщения";
            }
        }
        public void ОжиданиеПриемаПрерыванием() // для сценария с таймером и собственным потоком
        {
            try
            {
                Thread.Sleep(0); // блокировать поток
            }
            catch (ThreadInterruptedException){}
            if (ПроверитьИсходящие()) // в приоретете отправка сообщений
            {
                состояниеПриема = "передача сообщения";
                return;
            }
            состояниеПриема = "начат прием сообщения";
        }

        public void ОбработкаСигналаОтКанала() // для сценария с прерыванием
        {
            if (СобственныйПоток != null && СобственныйПоток.ThreadState==ThreadState.WaitSleepJoin)
            {
                СобственныйПоток.Interrupt(); //прерывание потока
            }
            else
            {
                РоднаяАктивность.ПолучиСообщение(this, Канал.ДайВходящее());
                //ЦиклОбработкиВходящих();// это очень долго
            }
        }

        void РеакцияНаОшибкуФорматаСообщенияКонец()
        {
            состояниеПриема = "окончание сеанса";
        }
        void РеакцияНаОшибкуФорматаСообщенияПовтор()
        {
            состояниеПриема = "ожидание приема";
        }
        public void Прием() // 
        {
            try
            {
                //идет прием писать нельзя 
                состояниеПриема = "идет прием сообщения";

                var сообщение = Канал.ДайВходящееСообщение(); //здесь поток блокируется пока не дочитается, не известно ответ это или команда 

                состояниеПриема = "сообщение получено";
                //сообщение получено
                // нужно синхронизировать передачу и прием, чтобы данные не пересекались, другой поток может начать писать в поток и потом ждать получения 

                //ЭТО ОПРЕДЕЛЕНИЕ ПРОТОКОЛА ОБЩЕНИЯ 
                var команда = сообщение as Команда;
                if (команда == null)
                {
                    Канал.ПередайИсходящееСообщение(new СтрокаЮникода("ошибка, ожидается команда"));
                    РеакцияНаОшибкуСообщениеНеКоманда();
                    return;
                }
                var сообщение2 = команда.Параметры[0];
                // здесь реакция зависит от типа сообщения и это можно перенести в Активность (часть не служебную)
                switch (команда.Имя.Значение)
                {
                    case "Сообщение": ПолучиСообщение(сообщение2);break;
                    case "Команда": ОбработкаКоманды(сообщение2); break;
                    case "СлужебнаяКоманда": ОбработкаСлужебнойКоманды(сообщение2); break;
                    case "ОтветНаКоманду": ОбработкаОтветНаКоманду(сообщение2); break;
                    default: //непредусмотренныйТип
                        break;
                }
                // данный свич можно заменить на Список Реакций СловарьРеакций(Т, Action<T>) таких списков может быть несколько переход Become = Стать переопредяляет этот словарь

                состояниеПриема = "ожидание приема";

            }
            catch (Exception e)
            {
                состояниеПриема = "обрыв сеанса";
            }

        }

        public virtual РАМОбъект УпаковатьСообщение(РАМОбъект сообщение)
        {
            // добавить проверку подлинности 
            return сообщение;

        }

        public virtual РАМОбъект РаспаковатьСообщение(РАМОбъект сообщение)
        {
            var команда = сообщение as Команда;
            // сюда встаить проверку подлинности 
            var сообщение2 = команда.Параметры[0];
            return команда;
        }

        // эта команда может использоваться напрямую внутри процесса для связи без канала 
        public virtual void ПолучиСообщение(РАМОбъект сообщение)
        {
            РоднаяАктивность.ПолучиСообщение(this, сообщение);
        }
        public virtual РАМОбъект ПолучиСообщениеСОтветом(РАМОбъект сообщение)
        {
            var ответ=РоднаяАктивность.ПолучиСообщениеСОтветом(this, сообщение);
            return ответ;
        }

        private void ОбработкаКоманды(РАМОбъект сообщение) // это получи собщение с ответом 
        {
            var команда = сообщение as Команда; 
            ТекущийНомерКоманды = (ЦелоеЧисло) команда.Параметры[0];
            var команда2 = команда.Параметры[1] as Команда;
            РезультатТекущейКоманды = РоднаяАктивность.ВыполнитьКоманду(команда2);
            //РезультатТекущейКоманды = РоднаяАктивность.ПолучиСообщениеСОтветом(this,команда2); //команда может не иметь ответа т.е. будет Пустота лучше 
            состояниеПриема = "идет передача ответа";
           
        }

        private ЦелоеЧисло ТекущийНомерКоманды;
        private РАМОбъект РезультатТекущейКоманды;
        void ПередачаОтвета()
        {
            var ответ = new Команда("ОтветНаКоманду", ТекущийНомерКоманды, РезультатТекущейКоманды);
            Канал.ПередайИсходящееСообщение(ответ);
            состояниеПриема = "ожидание приема";
        }

        public РАМОбъект ПередайКоманду(Команда команда)
        {
            var номерКоманды = new ЦелоеЧисло(0);
            var ком2 = new Команда("Команда", номерКоманды, команда);
            Канал.ПередайИсходящееСообщение(ком2);
            //здесь должно быть ДайВходящееСПрерыванием

            var команда2 = (Команда) Канал.ДайВходящее();
            var номерКоманды2 = команда2.Параметры[0]; // номер команды на которую дается ответ
            var ответ = команда.Параметры[1];
            return ответ;
        }
        private void ОбработкаОтветНаКоманду(РАМОбъект сообщение)
        {
            var команда = сообщение as Команда; // это ответ
            var номерКоманды = команда.Параметры[0]; // номер команды на которую дается ответ
            var ответ = команда.Параметры[1];
            // найти команду в истории по номеру
            // добавить ответ к команде
            // сообщить Активности о приходе ответа или запустить привязаную реакцию
            РоднаяАктивность.ПолучиСообщение(this, ответ);

            состояниеПриема = "окончание сеанса"; 
        }

        private void ОбработкаСлужебнойКоманды(РАМОбъект сообщение)
        {
            var команда = сообщение as Команда; 
            if (команда.НомерКоманды.Значение == 1 || команда.Имя.Значение == "прямая передача")
            {
                МетодПриемаСообщения = ПрямаяПередачаВАктивностьСОтветами; состояниеПриема = "начат прием сообщения"; return; }
            if (команда.НомерКоманды.Значение == 5 || команда.Имя.Значение == "конец связи") { состояниеПриема = "окончание сеанса"; return; }
        }

        private void ПрямаяПередачаВАктивностьСОтветами() //вся логика в Активности -это реакция = действие ответное (это значит что инициатор внешний) на сообщения
        {
            try
            {
                var сообщение = Канал.ДайВходящееСообщение();
                // сообщение может быть просто списком байт 
                var ответ = (РАМОбъект)РоднаяАктивность.ПолучиСообщениеСОтветом(this,сообщение);
                // это аналог GET HTTP
                Канал.ПередайИсходящееСообщение(ответ);
            }
            catch (Exception e)
            {
                состояниеПриема = "обрыв связи";
            }
        }

        private РАМОбъект ТекущееИсходящееСообщение;

        public void ПередайСообщениеВСвоемПотоке(РАМОбъект сообщение)
        {
            ТекущееИсходящееСообщение = сообщение;
            if (СобственныйПоток != null && СобственныйПоток.ThreadState == ThreadState.WaitSleepJoin)
            {
                СобственныйПоток.Interrupt(); //прерывание потока
            }

        }

        public virtual void ПередайСообщение(РАМОбъект сообщение) //это поток активности , ответ не предполагется 
        {
            try
            {
                //если отправлять сообщения разрешено,то
                // перед запуском отправки нужно проверить занато соединение или нет, можно отдать эту логику активности

                if (Канал.СоединениеУстановлено)
                {
                    var команда = new Команда("Сообщение", сообщение) { НомерКоманды = new ЦелоеЧисло(0)  };
                    // если поток не занят , то установить что поток занят - одновременно получать и передавать команды нельзя, лучше сделать два встречных соединения 
                    Канал.ПередайИсходящееСообщение(команда);
                     //перейти в ожидание ответа 
                    //var ответ = Канал.ДайВходящееСообщение();// отвкт Пустота как подтверждение
                }
            }
            catch (Exception)
            {
                Канал.СоединениеУстановлено = false; // 
            }
        }
        public virtual РАМОбъект ПередайСообщениеСОтветом(РАМОбъект сообщение) //это поток активности , ответ не предполагется 
        {
            try
            {
                if (Канал.СоединениеУстановлено)
                {
                    var сообщение2 = сообщение as Сообщение;
                    var команда = new Команда("Сообщение", сообщение2) { НомерКоманды = new ЦелоеЧисло() { Значение = 0 } };
                    // если поток не занят , то установить что поток занят - одновременно получать и передавать команды нельзя, лучше сделать два встречных соединения 
                    Канал.ПередайИсходящееСообщение(команда);

                    var ответ = Канал.ДайВходящее();
                    return ответ;

                }

            }
            catch (Exception)
            {
                Канал.СоединениеУстановлено = false; // 
                //Старт();// не все регистрацию нужно исключить 
            }
            return new Пустота();
        }

        

       
        public void Стоп()
        {
            Канал.Стоп();
        }

        // чистый клиент это всегда копия удаленного объекта 

        // это синхронный вариант , ассинхронный отправить коанду, и зарегистрировать и ждать прихода ответа, тогда в команде надо передовать метку команды, чтобы знать на какую команду пришел ответ
        // с активность метод ответа заранее известен, регистрировать ничего не надо, может разделить обратный вызов на команды, события 
        // а лучше подставить посредника, который будет сортировать - это большая гибкость
        // связь должна решать одну задачу- передачу сообщений иначе можно погрязнуть, еще уже установку соединения, и организацию поотока ввода-вывода


       }
}
