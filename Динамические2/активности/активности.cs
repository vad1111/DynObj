using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Динамические
{
    //объект отсылает сообщение если получает одновременно два сигнала
    // причем они могут поступать последовательно сначала один потом второй или просто накопительно
    //
    class ЛогическоеИ //накопительный тип
    {
        private bool первыйПришел;
        private bool второйПришел;
        private object ТаймерСброса;
        private object Подписчики;

        void ОтослатьСообщение()
        {
            // отослать сообщения подписчикам
        }
        void УсловиеОтослатьСообщение()
        {
            if (второйПришел & первыйПришел) ОтослатьСообщение();
        }

        void ПервыйПришел()
        {
            первыйПришел = true; УсловиеОтослатьСообщение();
        }
        void ВторойПришел()
        {
            if (!первыйПришел) return; // условие последовательного прихода
            второйПришел = true; УсловиеОтослатьСообщение();
        }

        void СбросВходящих()
        {
            первыйПришел = второйПришел = false;
        }

    }

    public class АктивностьОднопоточная : Активность
    {
        public Thread Процессор; //ИсточникАктивности; //  если не пусто объект является инициатором, источником сигналов-сообщений
                                    // процессор или свой или арендованный
        private int ВремяОжидания ; // "тактовая частота" срабатывания источника сигналов может регулироваться вплоть до остановки 
                                        // это один из ресурсов доступных активности
                                        // должен быть распределитель ресурсов иначе активность будет хирачить сообщения непрерывно, засирая все вокруг
                                        // не больше 10 сообщений в секунду например
        private bool Активен;

        private Queue<Сообщение> СписокСообщений; 

        public virtual void Запуск()
        { }

        void ЗапускСобственнойАктивности() // частный случай ПолучитьСообщение
        {
            Активен = true;
            Процессор.Start(ЦиклАктивности());
        }

        private object ЦиклАктивности() // активная активность - 
        {
            while (Активен)
            {
                while (СписокСообщений.Count != 0)
                {
                    var сообщение = СписокСообщений.Dequeue();
                    ОбработайСообщение(сообщение);

                }
                // вариант один поток на все связи 
                foreach (Связь связь in СписокСвязей)
                {
                    связь.ЦиклОбработкиВходящих();// запускается обработка входящих без "ожидания приема" правда
                    //либо логика здесь 
                    // проверяется входящий буфер
                    if (связь.Канал.ДоступноБайт() > 0)
                    {
                        связь.МетодПриемаСообщения();// запустить метод приема сообщения
                        //или сразу выполнить
                        var сообщ = new Сообщение();
                        ОбработайСообщение(сообщ);

                    }

                }

                // если это источник то входящих сообщений не бывает
                if(СписокКомуОтдать.Список.Count==0)
                // отослать сообщение настройщику о простое - поиск потребителей, или 
                // поиск цели существования, я должен выполнить свое предназначение, свою цель
                // отослать широковещательное сообщение, должен быть в списке исходящих, широковещательная активность это на самом деле ОбщаяАктиность, где СписокИсходящих = Списку Входящих

                ОтошлиСообщения("внутренние сообщения");   // может быть команда ПолучитьСообщение 
                Thread.Sleep(ВремяОжидания); // срабатывает после отправки всех сообщений 
            }
            return null;
        }

        public virtual void ОбработайСообщение(Сообщение сообщение)
        {
            
        }

        public override void ПолучиСообщение(Связь связь, РАМОбъект сообщение)
        {
            var сообщ= new Сообщение() ;
            ДобавитьСообщение(сообщ);
        }

        void ДобавитьСообщение(Сообщение сообщение)
        {
            СписокСообщений.Enqueue(сообщение);
        }

        object ЦиклПассивнойАктивности() //пассивная активность - запуск сервера-слушателя
        {
            while (Активен)
            {
                //ждать поступления сообщений , обработать поступающие сообщения
                // опрашивать почтовый ящик, некоторые ячейки памяти например
                // это делается через промежутки времени
                // или ждется прерывание ожидания = краткое сообщение - это запуск 
                   
                Thread.Sleep(ВремяОжидания); // срабатывает после отправки всех сообщений 
            }
            return null;
            
        }
    }

    public class АдресВАктивности : Адрес
    {
        public int номер;
        public Адрес АдресРОдительскойАктивности;
        public Активность АдресАктивностиВКуче;
        public override РАМОбъект АдресВКучеПамяти()
        {
            if (АдресАктивностиВКуче == null) АдресАктивностиВКуче = (Активность) АдресРОдительскойАктивности.АдресВКучеПамяти();
            var адресВКуче = АдресАктивностиВКуче.ДайСвязьПоНомеру(номер);
            return адресВКуче;
        }
    }


    //узел данных- действий
    // это не активность это рецепт т.к. не имеет процессора 
    // но эмулирует действие активности т.к. реализует обмен сообщениями
    public class Активность : РАМОбъект
    {
        public СтрокаЮникода Имя;
        // в список входящих может входить и двустороння связь
        // входящие могут регистрироваться во многих регистраторах, тогда СобственныйАдрес примитива будет не один, а целая Группа 
        public ГруппаОбъектов СписокСвязей = new ГруппаОбъектов();// здесь храняться все связи\

        public ГруппаОбъектов СписокОтКогоПолучить // Список Подрядчиков (те от кого нужно что-то получить)
        {
            get
            {
                //вернуть все связи с типом Поставщик
               return new ГруппаОбъектов() {Список = СписокСвязей.Список.FindAll(опись => ((Связь) опись).ТипСвязи == "входящая")};
            }
        } //если списка входящих нет или один то это рецептор или восстановитель
                                                                   // список входящих это список разрешений на отдачу команд = шаблон выбора (список типов)
                                                                   // тогда пересылка сообщений от активности идет не напрямую, а через активность представляющая Тип объект
                                                                   //!!!!!!!! вот оно обобщение и экономия ресурсов памяти 
        public ГруппаОбъектов СписокКомуОтдать  // Список Заказчиков  (тЕ кому надо что-то отдать) если списка исходящих нет то это примитив, или фокус
            // отдать можно по запросу-команде от обратной строны, 
            // по приказу от третей стороны (принудительно) - это натсройка из текста программы 
            //по внутреннему событию (произощло смена значения) заказчик=подписанту , если подписант может еще менять значение, то заказчик выступает уже подрядчиком (ему не надо посылать сообщение по плдписке)
            // чтобы офрмить подписку надо чтобы подрядчик отдал приказ об оформлении подписки, тогда он из подрядчика становиться заказчиком (меняет статус добавляет)
            // "чистые подписчики" могут давать только две команды (подписаться, отписаться) 
            // есть еще "кристально чистые подписанты", подписку им оформляет третья сторона,  у этих нет возможности поылать сообщения, только получать, часть методов можно удалить из связи
            // заказчик может поручить что-то сделать (не просто отдать объект), присылается рецепт, активность его принимает или отвергает (зависит от прав заказчика) если права не проверяются то может произойти захват собственности
            // выполнение рецепотов это уже свойство самой активности, хотя рецепт это тоже объект Значит у активности есть доступная команда"выполнить рецепт, запомнить рецепт, отдать рецепт, удалить рецепт"
            // таким образом активность может быть наделена любой способностью (правда она должна заместить свою программу на присланную, она даже может отключить способность принимать иные рецепты)
            // в списке заказчиков заказчики имеют разные права, а значит им будут доступны разные команды , получается список команд должен хранится в описании связи, нет он должен фильтроваться, каждая команда
            // должна иметь список прав (если ты подписант, то только две команды, если гость (Читатель) только чтение ограниченного списка данных)
            // не все активности нужно наделять проверкой прав, АктивностьОхранникДиспетчер проверяет права и пересылает сообщение дальше по уровню прав ,
            // Запрос прав = Запрос доступных команд
            // Покупатель это заказчик, которму доступны команды дай список товаров, добавить в корзину, оформиь заказ
            // Мне нужен конструктор Активностей. Есть общие методы, данные
            // Т.к. синхронное обработка сообщений останавливает один процесс и передает эстафету другому, то это выглядит как работа отдного процесса

            // Соединение спсобностей это добавление методов и данных в общую копиилку, эти данные и методы связаны и по анализу связей можно их выявить как способность, потом могут появиться новые связи с другими
            // спосбностями
            // Проблема что разные методы могут иметь одинаковые имена, а одинаковые методы разные имена или разную последовательность действий, тесты могут выявить одинаковые методы, анализ кода
            // 
        {
            get
            {
                //вернуть все связи с типом Поставщик
                return new ГруппаОбъектов() { Список = СписокСвязей.Список.FindAll(опись => ((Связь)опись).ТипСвязи == "исходящая") };
            }
        } 
      
        public ГруппаОбъектов ОкружениеОбщенияСАктивностью;
            // у каждой связи есть согласованное окружение ( общие справочники, общие объекты, согласованные шаблоны (протоколы) общения 
            // это все может содержаться в списке Входящих т.к. данный объект был вызван его окружением начиная с запуска компьютера, начальная точка окружения это компьютер
            // конечная точка это класс Хранилище и память процесса

        //public object ВнутренниеОбъекты; // внутренние ресурсы, если внутренних объектов нет, это просто набор реакций? пересылка сообщений дальше

        private Словарь СписокКоманд; //ассоциированный список команд
        private Словарь СписокСобытий;
        private Словарь СписокСостояний;
        private РАМОбъект ТекущееСостояние;
        private ГруппаОбъектов ПоследовательностьСеансаСвязи; // это может быть группа реакций (События- действия) или просто ряд действий, тогда он содержит текущий индекс последовательности
        // это не нужно т.к последовательность сеанса реализуется отдельной активностью у которой в исходящих записана последовательность этой связи 

          
        public Активность()
        {
            
        }
        // активность имеет свйоства группы - выполняет роль регистратора-диспетчера
        // это для связывания с другими активностями , только этот метод должен быть виден , можно унаследоватся от группы 
        // нужен спицифический собственный Адрес , чтобы запускать этот метод вместо индексера Группы 
        //
        public Адрес ДобавьСвязь(Связь описание) //это = получи адрес у регистратора , активность отличается от регистратора тем что соханяет порты и самми связи 
        {
            описание.РоднаяАктивность = this;
            var адресВГруппе = СписокСвязей.Добавить(описание);
            var адресВАктивности = new АдресВАктивности() {номер = ((АдресВГруппе) адресВГруппе).НомерВГруппе, АдресАктивностиВКуче = this, АдресРОдительскойАктивности = this.СобственныйАдресПримитива};
            описание.АдресСобственный = адресВАктивности;
            return адресВАктивности;
        }
        public Связь ДайСвязьПоНомеру( int номер)
        {
            return (Связь) СписокСвязей[номер];
        }
        public Связь ДайСвязьПоИмени(СтрокаЮникода имяСвязи)
        {
            return (Связь) СписокСвязей.Список.Find(связь => ((Связь)связь).ИмяСвязи == имяСвязи.Значение);
        }

        // зарегистрироваться как принимающая, если есть Входящие 
        // Восстановить входящие  связи
        public void ПопытатьсяВосстановитьДвусторонниеСвязи() // это не регистрация а активная попытка установить связь что можно делать, а так связь уже зарегистрирована  в активности
        {
            foreach(Связь связь in СписокОтКогоПолучить)
            {
                связь.Старт();
            }
        }
        //это реакция на сообщение
        public virtual void ПолучиСообщение(Связь связь, РАМОбъект сообщение) // получи, возьми это команда снаружи
        {                                   //возможно это единственная команда 
            // есть ожидаемый список сообщений
            // поиск реакции соответсвующий этому набору данных
            // если реакций много уточнение у пославшего какую именно реакцию требуется выполнить 
            // запуск этой реакции 
            var сооб = сообщение as Сообщение;
           
            //распознование сообщения это могут быть данные или команды из утверденного сценария связи ( сначала согласование типа протокола, потом пароли, потом обмен данными и командами)
        }

        public virtual void ПолучиСообщение(Активность активность, РАМОбъект сообщение)
        {  
        }

        public virtual РАМОбъект ПолучиСообщениеСОтветом (Связь связь, РАМОбъект сообщение)
        {
            return null;
        }

        

        public void СогласоватьОбщение( Активность активность )
        {
            //проверить окружение как совпадение групп 
            // хотя не все объекты окружения могут быть важны 
            // если активности в разных хранилищах этот код не пойдет, т.к. адреса состовляющих объектов могут быть разными 
            // группы моут иметь уникальный код, если они более неизменны, можно сравнить только этот код 
            if(ОкружениеОбщенияСАктивностью.Список.Count != активность.ОкружениеОбщенияСАктивностью.Список.Count) return;
            var генератор = new Random(DateTime.Now.Millisecond);
            for (int i = 0; i < 10; i++) // 10 проверок
            {
                var случайныйИндекс = генератор.Next(ОкружениеОбщенияСАктивностью.Список.Count);
                if ( ((АдресВХранилище) ОкружениеОбщенияСАктивностью.Список[случайныйИндекс]).НомерВХранилище != 
                    ((АдресВХранилище) активность.ОкружениеОбщенияСАктивностью.Список[случайныйИндекс]).НомерВХранилище )
                    return;
            }
        }

        public override void СохранисьВ(BinaryWriter писатель)
        {
            СписокСвязей.СохранисьВ(писатель);
        }

        public override РАМОбъект Восстановить(BinaryReader читатель)
        {
            СписокСвязей =(ГруппаОбъектов) РАМОбъект.Создать(читатель.BaseStream);
            return this;

        }

        public virtual void Закрыть()
        {
            
        }

        public void ОтошлиСообщения(object сообщение) //внешняя команда разновидность сообщения
        {
            ОтослатьСообщениеВсемИсходящим( сообщение);
        }

        //РЕАКЦИЯ - это внутренняя команда
        // это простейший вариант последовательности действий т.е. функция - последовательность список исходящих это строгая последовательность команд
        // = ВЫПОЛНИТЬ ПОСЛЕДОВАТЕЛЬНОСТЬ
        internal virtual void ОтослатьСообщениеВсемИсходящим(object сообщение)  //это внутрення реакция   внутреннее команда отдай  реакция на сообщения
        {
            // отослать сообщения подписчикам
            foreach (var получатель in СписокКомуОтдать.Список)
            {
               ((Связь) получатель).ПередайСообщение((РАМОбъект) сообщение);
            }
            
        }


        public virtual void Запуск()
        {
            throw new NotImplementedException();
        }
    }

    //фокус это объект который активирует нужные узлы и гасит ненужные, выборщик кодировки символов например или приследуемая цель

}
