using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Динамические.активности;

namespace Динамические
{
    // ТСП адрес плохой т.к. не содержит цепочки посредников, может прийти по  скрытым переадресациям
    // это адрес относительно целой системы служб сети 
    public class ТСПАдрес : Адрес
    {
        public override bool ЭтоАдресВПямяти=>false;

        //Регистратор здесь служба ТСП это относительный адрес 
        public string IPАдрес;
        public int порт;
        // надо задавать сразу пару адресов 
        //public КаналТСП КаналТ; //= Регистратор

        public ТСПАдрес()
        {
        }

        private IPEndPoint _IpEndPoint;
        public IPEndPoint IpEndPoint => _IpEndPoint ?? new IPEndPoint(IPAddress.Parse(IPАдрес), порт);

        public override Связь СоздатьСвязь() // здесь надо указывать тип связи, нужна еще команда дайДоступныеТипыСвязи
        {
            return new Связь() { АдресУдаленнойСвязи = this}; //исходящая не понятно какую связь давать входящую, исходящую, двустороннюю
        }

        public override Type ТипКанала()
        {
            return typeof(КаналТСП);
        }
    }
    // содержит одновременно и клиент и сервер
    // как клиент ему можно передавать сообщения, как сервер от него можно ждать сообщений (он является инициатором запуска активности)
    // как клиент он содержит команду ВыполниКоманду (получиСообщение, передай сообщение) 
    // как сервер он содержит команду ЗапомниАдресДляПередачиСообщения (команды)
    // это не почтовый сервер, т.к. является инициатором 
    // эти команды от объектов внутренних из хранилища которые являются разновидностью передачи сообщений
    // команда это простеший протокол обмена сообщениями = получи и ответь 
    // потоковое передача данных может не подходить т.к. получается команда, начинает передавться поток, одновременно слушается прием новых команд, которые могут менять или нет передачу потока

    // это связь как отдельный объект , в активности 
    public class КаналТСП: Канал
    {
        private IPEndPoint собственныйАдрес =>((ТСПАдрес) АдресСобственный)?.IpEndPoint;
        private IPEndPoint УдаленныйАдрес => ((ТСПАдрес)АдресУдаленнойСвязи).IpEndPoint;

        public override int ВремяОжиданияПриема => каналСвязи.ReceiveTimeout;

        private TcpListener Слушатель; //входящее соединение 
        private TcpClient каналСвязи; // клиент только один 
        private NetworkStream поток;

        public override int ДоступноБайт() => каналСвязи.Available;

        public КаналТСП()
        {
            //Получи = null;
            ПередайИсходящееСообщение = ПередайСообщениеВПоток;
        }

        public void Старт() // вся логика подходит для разных типов связи,точнее каналов связи стоит перевести ее в оПисание связи, здесь оставить только Регистрацию, Устанвить связь, Стоп
        {
           
        }

       
        public override bool УстановитьСвязь() // заполнить адрес, затем вызвать этот метод = ПолучитьОбъект
        {
            if (каналСвязи != null) return true;
            try
            {
                каналСвязи = new TcpClient();

                if (собственныйАдрес != null) каналСвязи.Client.Bind(собственныйАдрес);
                //клиент.SendTimeout = ВремяОжиданияоединения; // ввести параметр это или парметр статический или метод 
                каналСвязи.Connect(УдаленныйАдрес);

                if (собственныйАдрес == null)
                {
                    var свойАдрес = (IPEndPoint)каналСвязи.Client.LocalEndPoint;
                    Связь.АдресСобственный = new ТСПАдрес() {IPАдрес = свойАдрес.Address.ToString(), порт = свойАдрес.Port};
                }

                СоединениеУстановлено = true;
                поток = каналСвязи.GetStream();
                return true;
            }
            catch (SocketException e)
            {
                var ошибкаСокета = e.SocketErrorCode;
                switch (ошибкаСокета)
                {
                    case SocketError.TimedOut: break; // тайм аут
                    case SocketError.ConnectionRefused: break; // отказ в соединении, порграммный отказ
                    case SocketError.AddressAlreadyInUse: break; // адрес уже занят это наверно для Bind - ошибки Регистратора
                    case SocketError.ConnectionReset: break; // разные обрывы связи - 

                }
            }
            catch (Exception e)
            {
                 
            }
            //если связь не удалось установить
            каналСвязи.Close();
            каналСвязи = null;
            return false; 
        }

        public override void Регистрация()
        {
            Слушатель = new TcpListener(собственныйАдрес);
            Слушатель.Server.NoDelay = true;// посылать все точно, не накапливать малые данные
            Слушатель.Start(1);
        }

        public void ПередайСообщениеВПоток(РАМОбъект сообщение)
        {
           сообщение.СохранисьВ(поток);
        }

        public override РАМОбъект ДайВходящееСообщение()
        {
            return Создать(поток);
        }


        public override void Стоп()
        {
            Слушатель.Stop();
            СоединениеУстановлено = false;

            каналСвязи.Close();
        }

        // чистый клиент это всегда копия удаленного объекта 

            // это синхронный вариант , ассинхронный отправить коанду, и зарегистрировать и ждать прихода ответа, тогда в команде надо передовать метку команды, чтобы знать на какую команду пришел ответ
            // с активность метод ответа заранее известен, регистрировать ничего не надо, может разделить обратный вызов на команды, события 
            // а лучше подставить посредника, который будет сортировать - это большая гибкость
            // связь должна решать одну задачу- передачу сообщений иначе можно погрязнуть, еще уже установку соединения, и организацию поотока ввода-вывода

        
       
        public override void ОжидатьПодключение()
        {
                
                каналСвязи = Слушатель.AcceptTcpClient(); // ожидание подключения 
                //проверка подлинности
                if (! ПроверкаПодлинности())
                {
                    каналСвязи.Close(); // отказ в соединении
                    return;
                }

                поток = каналСвязи.GetStream();
                СоединениеУстановлено = true;
                
        }

        public bool ПроверкаПодлинности()
        {
            var адресПодключившегося = (IPEndPoint)каналСвязи.Client.RemoteEndPoint;

            return адресПодключившегося.Port == УдаленныйАдрес.Port &&
                   адресПодключившегося.Address.ToString() == УдаленныйАдрес.Address.ToString();

        }
        
        
    }
}
