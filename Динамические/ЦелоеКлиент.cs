using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Динамические;

namespace Динамические
{
    // это заместитель без хранения копии 
    public class ЦелоеКлиент: Примитив
    {
        public ТСПСвязьИсходящая Связь;

        
        static ЦелоеКлиент()
        {
            //Команды.AddRange(ЦелоеЧисло.Команды); //  копируются все команды
            var ком = new РеакцияНаКоманду() { Имя = "ДайЗначение", Инструкция = typeof(ЦелоеКлиент).GetMethod("ДайЗначение") };
            РеакцииНаКоманды.Add(ком); // В кленте выполнение команды замениться установление связи и отсылку команды серверу
            ком = new РеакцияНаКоманду() { Имя = "НаЗначение", Инструкция = typeof(ЦелоеКлиент).GetMethod("НаЗначение") };
            РеакцииНаКоманды.Add(ком);
        }
        //public override object ДайЗначение()
        //{
        //    var команда = new Команда() {Имя = new Строка() { Значение = "ДайЗначение" } }; // это всегда одинаковое
        //    return Связь.ВыполнитьКоманду(команда);
        //}

        //public override object НаЗначение(object значение)
        //{
        //    var команда = new Команда() { Имя = new Строка() { Значение = "НаЗначение" }, Параметры = new ГруппаОбъектов()  };
        //    команда.Параметры.Добавить((ЦелоеЧисло) значение);
        //    return Связь.ВыполнитьКоманду(команда);
        //}

        // добавить Сохранить и восстановить свойства здесь сохраняется связь
    }
}


// это универсальный заместитель любого объекта 
// имея адрес можно узнать что это или сранить с тем что известно (будет тип)
// получение адресов сложная штука, если мы получаем группу адресов, то это группа содержит адреса относительно удаленного объекта, сами объекты могут не передаваться
// но это для случая если это заместитель этой группы, в адрес надо добавить еще номер группы в хранилище
public class ТСПСвязьИсходящая : Связь
{
    //адрес должен иметь метод ПолучитьОбъект = ЦелоеСервер, получается доступ к его буферу обмена (поток)
    //это исходящая связь
   
    public ТСПАдрес АдресТСП;

    public int ВремяОжиданияоединения=0;
    public Func<int> МетодВыбораВремениОжидания;
   
    private TcpClient клиент ;
    public NetworkStream поток;


    public override bool УстановитьСвязь() // заполнить адрес, затем вызвать этот метод = ПолучитьОбъект
    {
        try
        {
            // соединиться
            клиент = new TcpClient();
            клиент.SendTimeout = ВремяОжиданияоединения; // ввести параметр это или парметр статический или метод 
            клиент.Connect(АдресТСП.IPАдрес, АдресТСП.порт);
            // после соединения 
            поток = клиент.GetStream();
            return true;
        }
        catch (Exception e)
        {
            if (e as SocketException !=null)
            {
               var  ошибка =e.Data["кодОшибки"];
                return false;
            }
        }

        return false; //если связь не удалось установить
    }

    

    public override ПримитивИлиАдрес ВыполнитьКоманду(Команда команда)
    {
        //добавить команду в очередь, если очередь есть 
        if(клиент==null || !клиент.Connected)
        {
            var  рез= УстановитьСвязь(); // если связь установить не удалось 
            if(рез==false) return new Строка("сервер не доступен"); // или запуск метода обработки 
        }


        var команда2 = new Команда("ПередайКомандуОбъекту", команда); // команда серверу это связь на стороне приемника

        команда.СохранисьВ(поток);

        var результат = ПримитивИлиАдрес.Создать(поток);

        if(!СохранятьСвязь)
        {
            клиент.Close();
            клиент = null;
        }

        return результат;
    }

    public void ОшибкаПодключенияКСерверу()
    {
        // сообщить активности проверки подключений об ошибке передать свой адрес по адресу доступен тспАдрс
        // если команда может потерпеть или ее исполнение обязательно, то ждать пока связь востановиться
        // если команда зависит от окружения, то есть время ожидания, после которого необходимость команды надо пересмотреть
    }
}



// этот заместитель сам проверяет обновление по мере запроса, другой вариант с подпиской где инициатор удаленный объект
// объекты все динамические, т.е. может меняться спиок команд 
// типы заместителей 1. посредник - копия не сохраняется
// 2. хранитель копии (кэш) 2.1 почти достоверный перед командой всегда скачивать последнюю версию объекта 2.2. сомнительный качать версию время от времени, необходимо добавить время последнего обновления
// 2.3. сомнительный - подписчик - инициатор удаленный объект (риски ошибки недоступность связи, устаревшие данные) - аналог кэша (все хранители копий это кэш) 
// сомнительность может уменьшиться если связи надежные (например внутри одного процесса)
// заместитель может быть типизированный т.е. тип объекта всегда сохраняется и тип сохраняется как свойство (копия объекта может не сохраняться)
// чистый посредник не сохраняет ни копию, ни тип, только адрес
public class Посредник : ПримитивИлиАдрес
{
    public Адрес ПолныйАдресОбъекта;
    public ТСПСвязьИсходящая ТспСвязь;

    // только для хранителя копий (добавить еще версию, время обновления, способ обновления, тип хранителя, степень риска, список рисков 
    // для контроля ресурсов нужно добавить размеры входного и исходящего буфера (для целого цисла нет смысла в большом буфере) 

    // спиок команд к заместителю должен совпадать со списком команд к самому объекту
    // сценарий его восстановления 
    // востанавливается адрес удаленный , возможно копия , если сервер или сервера не доступен
    // устаналивается связь ТСП 
    // передается команда ДайОбъектПоИндексу, получается группа адресов
    // в этой группе ищется адрес по индексу (поиск может проводиться и на сервере надо особо указывать)
    // получается адрес объекта , снова Команда ДайОбъектПоИндексу 
    // получается конечный объект (например Целое), можно и не получать копию объекта Это всего лишь кэш, где можно получить его значение (возможно устаревшее)
    // посылается команда к объекту ДайЗначение (хотя Целое это уже примитив) 
    // каждый раз Получая команду от внешнего по отношению к заместителю объекта ДайЗначение надо проходить всю процедуру заново, получать целое и уже его возвращать 
    // здесь адрес уже нужен в форме команды, тогда можно указать последовательность действий, чтобы не скачивать группу адресов 

    // заместитеь можно использовать как шлюз ко всем удаленным объектам с одним IP 
    // т.е. это доступ к целой группе например по индексу и копияудаленного объекта все время разная 
    // правда адреса у всех объектов разные и тогда смысла в адресе нет 



    // это команды к заместителю, хотя можно обратиться к копииУдаленногоОбъекта, к кому напрвлять команды зависит от спосба хранения копии
    // 1 способ полностью скачать объект и команды к копии, 
    // 2 не качать объект, переправлять все команды к удаленному объекту 
    public ПримитивИлиАдрес Выполнить( Команда команда)
    {
        var команда2 = new Команда() { Имя = new Строка() { Значение = "ВыполниКоманду" } };
        команда2.Параметры[0] = команда;
        
        var рез = ТспСвязь.ВыполнитьКоманду(команда2); //для 
        return рез;
    }

    

    public ГруппаОбъектов СписокКоманд() // надо заменить на группу (группу адресов или закрытую группу, группа адресов требует повторных запросов, добавить генерик группу (типизированную)
    {
        var команда = new Команда() { Имя = new Строка() { Значение = "ДайКоманды" } };
        return (ГруппаОбъектов) Выполнить(команда); 
    }

    public ПримитивИлиАдрес ТипУдаленногоОбъекта; // это получается универсальный объект, первый запрос это тип объекта, команды могут приниматься и без знания типа

}




public class ХранительКопии : ПримитивИлиАдрес
{
    public ТСПСвязьИсходящая ТспСвязь;
    public АдресУниверсальный ПолныйАдресОбъекта = new АдресУниверсальный() { КомандаОбъекту = new Команда("ПередатьИПолучить") }; // полный адрес содержит сам объект 
    public Команда ОтносительныйАдресОбъекта = new Команда("ДайОбъект", new АдресВХранилище() { НомерВХранилище = 10 }); // относительный адрес не содержит объект относительно кого этот адрес

    public ХранительКопии()
    {
        ПолныйАдресОбъекта.Регистратор = ТспСвязь; // 
    }
    // только для хранителя копий (добавить еще версию, время обновления, способ обновления, тип хранителя, степень риска, список рисков 
    // для контроля ресурсов нужно добавить размеры входного и исходящего буфера (для целого цисла нет смысла в большом буфере) 


    public ПримитивИлиАдрес АдресВКучеКопияУдаленногоОбъекта; //здесь точная копия удаленного объекта адресация = ТСП+ индекс+ внутренний адрес
    // этот адрес может быть адресом внутри группы или адресом в куче в другой вышестоящей группе, а может сразу в нескольких группах
    //в данном случае это поле в экземпляре объекта (т.е. внутри группы), хотя сам объект внутри кучи 

        //это адрес при перемещении копии в хранилище, а не внутри Хранителя копии. Копия отделяется от оригинала и к ней можно обращаться через Хранилище
        // наверно это другой сценарий вынести в другой класс
    public АдресВХранилище АдресВХранилище_КопииУдаленногоОбъекта; // т.к. это примтив у него уже есть это поле, но поле это самого ХранителяКопии


    public DateTime ВремяОбновления;

    public void ПолучитьКопию()
    {
        var адрес = new Команда("ДайОбъект", new АдресВХранилище() { НомерВХранилище = 10 }); // команда Хранилищу

        var команда2 = new Команда("ПередайКомандуОбъекту", ПолныйАдресОбъекта); // команда серверу это связь на стороне приемника

        var команда = new Команда("ПередатьИПолучить", команда2) ; // команда ТСПСвязи клиенту это и есть адрес связь на стороне передадчика

        АдресВКучеКопияУдаленногоОбъекта = ТспСвязь.ВыполнитьКоманду(команда); // создается новый объект и его адрес помещается в поле, старый объект в мусорку
        var старыйАдресВХрнилище = АдресВХранилище_КопииУдаленногоОбъекта; // что-то надо с ним сделать, пометить на удаление 
        АдресВХранилище_КопииУдаленногоОбъекта = Хранилище.Добавить(АдресВКучеКопияУдаленногоОбъекта); // добавляется в конец, старый адрес забывается 


        АдресВКучеКопияУдаленногоОбъекта = ТспСвязь.ВыполнитьКоманду(new Команда("ДайОбъект")); //это для получения самого объекта  примитива группы 
        АдресВКучеКопияУдаленногоОбъекта.СобственныйАдресПримитива = ПолныйАдресОбъекта; // обращение по команде Выполнить(команда) должно содержать 
        // обработка Копии объекта 
        // если Копия это адрес, то его надо дополнить адресом ПолнымАдресомОбъекта 

    }
    public ПримитивИлиАдрес Выполнить(Команда команда) // схоже с получи сообщение в активности 
    {
        ПолучитьКопию();
        var рез = АдресВКучеКопияУдаленногоОбъекта.ВыполнитьКоманду(команда); // если это группаадресов, а адреса эти в другом удалееном  хранилище, то потребуются запросы 
        // адреса получаемые надо модифицировать добавляя текущий адрес объекта 
        // команда "дайобъектПоиндексу (10)" копия содержит адрес в удалееном хранилище 
        // или в момент получения группы по команде ДайОбъект  
        return рез;
    }

    public List<Команда> СписокКоманд() // надо заменить на группу (группу адресов или закрытую группу, группа адресов требует повторных запросов, добавить генерик группу (типизированную)
    {
        return АдресВКучеКопияУдаленногоОбъекта.ДайКоманды;
    }
}

