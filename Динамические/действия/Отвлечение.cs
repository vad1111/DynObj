using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Динамические.действия
{
    public class Отвлечение  : План
    {
        public bool Активна = true;// можно скрыть
        public object Окружение;
        public ГруппаСВыбором<string> Состояния;
        public Отвлечение ВызвавшийСценарий;
        // чтобы получить нечеткий сценарий, вместо одного варианта может быть много
        // если ГРуппаСВЫбором, то настраиваемые ВариантыДействий
        // если просто список, то нечеткий абсолютно, если с весами, то самонастраиваемый
        // самонастриваемый это наличие тестов на скорость, сбойность, затратность
        // наличие истории использования
        // вместо стринг нужно указать элемент группы
        // ПРимитвИЛиАдрес содержит собственный адрес, это адрес в группе
        // наверно стоит оставить один собственный адрес в примитиве
        // если собствееных адресов много это уже не примитив, внутри появляется Группа это уже составной объект

        public Dictionary<string,Action<Отвлечение>> ВариантыДействий = new Dictionary<string, Action<Отвлечение>>();

        public Отвлечение()
        {
            Состояния = new ГруппаСВыбором<string>();
            ДобавитьДействие("выход",Выход);
        }
        public void ДобавитьДействие(string имя, Action<Отвлечение> действие)
        {
            if(!Состояния.Варианты.Contains(имя)) Состояния.Варианты.Add(имя);
            ВариантыДействий[имя] = действие;

            var вариантыДействий = new ГруппаСВыбором<Action<Отвлечение>>();
            вариантыДействий.Варианты.Add(действие);
            вариантыДействий.ТекущийИндекс = 1;
            // если таких вариантовДействий несколько в одном объекте, они должны синхронизироваться, если водном выбран индекс 1 то в другом только 2(или 2 и3 появляются ограничения) например, это можно сделать группой наборов действий, типа если злой набор реакций один, добрый - другой , команды те же, реакции разные (Тело метода - это реакция)
        }
        public void Старт()
        {
            while (Активна)
            {
                ВариантыДействий[Состояния.ТекущееЗначение].Invoke(this);
            }
        }

        void Выход(Отвлечение о)
        {
            о.Активна = false;
        }
        
    }

    // выбор единственного из возможных вариантов
    // команда одна - реакция одна, но из вариантов  
    // команда может иметь одно имя, но разное колво парметров -это перегрузка 
    // если ввсети типизированный класс, то сигнатура будет одна, имена могут быть разные
    public class ВариантРеакции
    {
        public Delegate ТекущееДействие => Варианты[ТекущийИндекс];
        public int ТекущийИндекс;
        public List<Delegate> Варианты;
        public ВариантРеакции()
        {
            Варианты = new List<Delegate>();
        }

        public object Выполнить(params object[] параметры)
        {
            return ТекущееДействие.DynamicInvoke(параметры);
        }
    }
    public class ВариантРеакции<T> 
    {
        public T ТекущееДействие => Варианты[ТекущийИндекс];
        public int ТекущийИндекс;
        public List<T> Варианты= new List<T>();
       

        public object Выполнить(params object[] параметры)
        {
            var d = ТекущееДействие as MulticastDelegate;
            return d?.DynamicInvoke(параметры);
        }
    }

    // событий  может быть много например интересует когда по индексу и будет добавлен объект типа Т
    // любое добавление , вставка, удаление, изменение элемента 
    // сам подписант добавляет событие в список событий источника - а источник событий должен модифицировать свой код, чтобы фиксировать событие 
    // либо источник должен отслеживать каждый свой шаг ироверять есть ли подписка на событие 
    public class СвойствоПодписки
    {
        public List<string> СписокСобытий;
        public List<List<ПримитивИлиАдрес>> АдресаПодписчиковНаСобытие;
        public Dictionary<Строка, List<Action<object>>> СписокРеакцийНаСобытие;

        public void ДобавитьАдресКСобытию(ПримитивИлиАдрес адрес, string ИмяСобытия)
        {
            var номер = СписокСобытий.IndexOf(ИмяСобытия);
            АдресаПодписчиковНаСобытие[номер].Add(адрес);
        }

        public void СообщитьОСобытии(Адрес адресОтКого, int номерСобытия) // желательно еще описание событие типа "добавлен элемент по индексу и" т.к. событие может устареть
        {
            if (АдресаПодписчиковНаСобытие[номерСобытия] != null)
            {
                foreach (var адрес in АдресаПодписчиковНаСобытие[номерСобытия])
                {
                    //адрес.РеакцияНаСобытие(адресОтКого, адресСобытия );
                }
            }
        }

    }

    public class ГруппаСВыбором<T>
    {
        public T ТекущееЗначение => Варианты[ТекущийИндекс];
        public int ТекущийИндекс;
        public List<T> Варианты;
        public ГруппаСВыбором() 
        {
           Варианты = new List<T>();

        }

    }
}
