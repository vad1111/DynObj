using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Динамические.действия
{
    public class ОпределениеКласса : ПримитивИлиАдрес // например имена полей это может быть список внутренних переменных для Действий 
    {
        public string ИмяКласса;
        public List<ОпределениеПоля> СписокОпределеныхПолей;

        public List<string> СписокИменПолей;
        public List<string> СписокТиповПолей;
 
        public List<ОпределениеМетода> СписокОпределеныхМетодов; 
        public int ДайНомерПоля(string имяПоля)
        {
            int номерПоля;
            for (номерПоля = 0; номерПоля < СписокИменПолей.Count; номерПоля++)
            {
                if (СписокИменПолей[номерПоля] == имяПоля) return номерПоля;
            }
            return -1;
        }
    }
    public class ОпределениеПоля //
    {
        public string ИмяПоля; // тут может быть список полей для разных языков
        public string ИмяТипа; // тут может быть перечисление типов
    }
    public class ОпределениеМетода // Метод отличается от функции наличием дополнительного справочника переменных в виде Списка Полей 
    {
        public string ИмяМетода; //
        public string ИмяТипаВозрата; // 
        public object ОпределениеКласса; // это дополнительный справочник переменных доступный в теле метода
        public List<string> ИменаПараметров;
        public List<План> ТелоФункции;
    }
    public class ОпределитьКласс: План // это действие может заменить собой ОпределениеКласса, т.к. содержит в себе список внутренних переменных аналогичный списку определения полей
    {
        //параметры Действия
        public string ИмяКласса;
        public List<ОпределениеПоля> СписокОпределенияПолей; // например имена полей это может быть список внутренних переменных
        
        public override object Выполнить(План вызывающееДействие) // это может быть и не действие а другой класс
        {
            
            вызывающееДействие.СловарьВнутреннихПеременных.Add(ИмяКласса,this);
            вызывающееДействие.СловарьТипизированныхПеременных.Add(ИмяКласса, new ТипизированноеЗначение(){ИмяТипа = "Определение Типа",Значение = this});
            // проверить незанятость Имени Типа 
            bool имяЗанято =вызывающееДействие.СписокТипизированныхПеременных.Exists( пер => пер.ИмяПеременной == ИмяКласса);
            if (!имяЗанято)
            {
                var новыйКласс = new ОпределениеКласса(){ИмяКласса = ИмяКласса,СписокОпределеныхПолей= СписокОпределенияПолей};
                
                вызывающееДействие.СписокТипизированныхПеременных.Add(new ТипизированнаяПеременная()
                {
                    ИмяПеременной = ИмяКласса,
                    ИмяТипа = "Определение Типа",
                    Значение = новыйКласс // или this, это если данные совпадают с действием 
                });
            }
            else
            {
                return "имя занято";
            }
            
            return "готово";
        }
    }

    // изменить класс

    public class ЭкземплярКласса: ПримитивИлиАдрес // 
    {
        public ОпределениеКласса Класс;
        public List<ПримитивИлиАдрес> СписокЗначений;

    } 
    
    public class СоздатьЭкземплярКласса : План // это new ТИп()
    {
        public string ИмяКласса;
        public override object Выполнить(План вызывающееДействие)
        {
            var определениеКласса = (ОпределениеКласса) вызывающееДействие.СловарьВнутреннихПеременных[ИмяКласса];
            var экземпляр = new ЭкземплярКласса
            {
                Класс = определениеКласса,
                СписокЗначений = new List<ПримитивИлиАдрес>
                {
                    Capacity = определениеКласса.СписокОпределеныхПолей.Count // ограничение в создании полей
                }
            };
            РезультатДействия = экземпляр;
            

            foreach (var определениеПоля in определениеКласса.СписокОпределеныхПолей)
            {
                // создать экземпляры классов для всех полей
            }
            return РезультатДействия;

            return "готово";
        }
    }
    public class ПрисвоитьЗначениеПолю : План
    {
        public ЭкземплярКласса экземпляр; // это возможно действие ДайЗначениеПеременной (Имя)
        public string ИмяПоля;
        public object ПрисваиваемоеЗначение;
        public override object Выполнить(План вызывающееДействие)
        {

            var определениеПолей = экземпляр.Класс.СписокОпределеныхПолей;
            int номерПоля = экземпляр.Класс.ДайНомерПоля(ИмяПоля); 
            if (номерПоля == -1) return "ошибка: нет такого поля";
           
            var типПоля = определениеПолей[номерПоля].ИмяТипа; 
            if ( типПоля != ((ЭкземплярКласса) ПрисваиваемоеЗначение).Класс.ИмяКласса) return "ошибка: несовпадение типов";
            
            экземпляр.СписокЗначений[номерПоля] = (ПримитивИлиАдрес) ПрисваиваемоеЗначение; return "готово";
        }
    }
    

    

    public class ТипизированноеЗначение // это уже не просто строка а 
    {
        public string ИмяТипа;
        public object Значение;

    }
    public class ТипизированнаяПеременная // это уже не просто строка а 
    {
        public string ИмяПеременной;
        public string ИмяТипа;
        public object Значение;

    }

   
}
