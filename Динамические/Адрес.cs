using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Динамические
{
    // Установитьсвязь нужно перенести в связь и АдресВкуче как канал должен находииться внутри , ВиртуальнаяСвязь может возвращать АдресВкуче для отдачи команд через точку 
    // а адрес должен содержать только данные адреса 
    public class Адрес : ПримитивИлиАдрес
    {
        public virtual bool ЭтоАдресВПямяти { get; }
        public Адрес АдресРегистратора;
        public virtual ПримитивИлиАдрес АдресВКуче() //=(Установить связь) объект нужен только чтобы отдавать ему команды (получать значения)Возвращает адрес в Куче
        {
            return null;
        }
        public virtual Type ТипКанала()
        {
            return null;
        }
        public virtual Связь СоздатьСвязь()
        {
            return null;
        }

        public override void СохранисьВ(BinaryWriter писатель)
        {
            //писатель.Write(Хранилище.кодыТипов[this.GetType()]);
        }
        public override ПримитивИлиАдрес Восстановить(BinaryReader читатель)
        {
            АдресРегистратора = (Адрес)ПримитивИлиАдрес.Создать(читатель.BaseStream);

            // востановление происходит в другом адресном пространстве 
            // если это адрес из другого адресногопространства тто его можно не менятть
            // если локальное, то нужно добавить адрес удаленной машины
           
            return this;
        }

        public Адрес Восстановить(Связь связь)
        {
            var адрес = (Адрес) связь.Канал.ДайВходящееСообщение(); // может быть замкнутый цикл
            Адрес конечныйАдрес;
            if (!(адрес is АдресАбсолютный))
            {
                конечныйАдрес = new АдресАбсолютный()
                {
                    АдресРегистратора = связь.АдресУдаленнойСвязи,
                    АдресОтносительный = адрес
                };
            }
            else конечныйАдрес = адрес;
            //возможно нужно вставлять копию связи целиком
            // если активность становиться посредником, то адрес регистратора будет собственый локальный адрес активности 
           
            return конечныйАдрес;
        }
    }

    public class АдресАбсолютный : Адрес
    {
        public Адрес АдресОтносительный;
    }
    
   
    public class АдресУниверсальный : Адрес
    {
        public ПримитивИлиАдрес Регистратор; //объект тоже может быть абсолютным адресом и вычисляться, если это не абс адрес, то он просто сохраняется и восстанавливается 
                                             // регистратор это асегда группа 
        public Команда КомандаОбъекту; // это относительный адрес
    }
    
    public class АдресВГруппе : Адрес //== команда , это адрес для самой группы где хранится объект 
    {
        public override bool ЭтоАдресВПямяти => true;
        public int НомерВГруппе;
        public Группа АдресГруппыВкуче;
        public override ПримитивИлиАдрес АдресВКуче()
        {
            if (АдресГруппыВкуче == null) АдресГруппыВкуче = (Группа) АдресРегистратора.АдресВКуче();
            return АдресГруппыВкуче[НомерВГруппе];

        }
        public override void СохранисьВ(BinaryWriter писатель)
        {
            base.СохранисьВ(писатель);
            АдресРегистратора.СохранисьВ(писатель);
            писатель.Write(НомерВГруппе);
        }
        public override ПримитивИлиАдрес Восстановить(BinaryReader читатель)
        {
            АдресРегистратора =(Адрес) ПримитивИлиАдрес.Создать(читатель.BaseStream);
            НомерВГруппе = читатель.ReadInt32();
            return this;
        }
        public override string ToString()
        {
            var строка = АдресРегистратора + "/";
            return строка+ "АдресВГруппе(" + НомерВГруппе+")";
        }

        public override ПримитивИлиАдрес Копировать()
        {
            return new АдресВГруппе(){НомерВГруппе = НомерВГруппе,АдресГруппыВкуче = АдресГруппыВкуче, АдресРегистратора = АдресРегистратора};
        }
    }

    public class АдресВФайле : Адрес
    {
        public int НомерВФайле; // почему-то целое (нужно целое переменной длины )
        public ДисковоеХранилище АдресГруппыВкуче;
        public override ПримитивИлиАдрес АдресВКуче()
        {
            if (АдресГруппыВкуче == null) АдресГруппыВкуче = (ДисковоеХранилище) СобственныйАдресПримитива.АдресВКуче();
            return АдресГруппыВкуче.ПрочитатьОбъект(НомерВФайле);
        }
        public override void СохранисьВ(BinaryWriter писатель)
        {
            писатель.Write(Хранилище.кодыТипов[СобственныйАдресПримитива.GetType()]);
            СобственныйАдресПримитива.СохранисьВ(писатель);
            писатель.Write(НомерВФайле); // сохраняется только адрес в файле
        }
        public override ПримитивИлиАдрес Восстановить(BinaryReader читатель)
        {
            СобственныйАдресПримитива = new Адрес();
            СобственныйАдресПримитива = (Адрес) СобственныйАдресПримитива.Восстановить(читатель);
            НомерВФайле = читатель.ReadInt32();
            return this;
        }

    }
    public class АдресВХранилище : Адрес //ссылается на статичсеский диспетчер, загружается по умолчанию
    {
        public int НомерВХранилище; //Номер в хранилище.Память
        // Регистратор == null

       public override ПримитивИлиАдрес АдресВКуче() // возращаться должа связь, куда можно посылать сообщения- в частности команды для объектов С# точка после имени переменной это анлог командыВыполниКоманду
        {
            var адресВкуче = Хранилище.Память[НомерВХранилище];
            return адресВкуче;
        }
        public override void СохранисьВ(BinaryWriter писатель)
        {
            писатель.Write(НомерВХранилище);
        }

        public override ПримитивИлиАдрес Восстановить(BinaryReader читатель)
        {
            НомерВХранилище = читатель.ReadInt32();
            return this;
        }

        public override string ToString()
        {
            return "АдресВХранилище(" + НомерВХранилище+")";
        }

        internal АдресВХранилище Копия()
        {
            return new АдресВХранилище() { НомерВХранилище = НомерВХранилище};
        }
    }



    public class АдресВПамяти : Адрес // это равно адрес в Хранилище, у нас Хранилище представляет память 
    {
        private static Строка диспетчер = new Строка { Значение = "Диспетчер" };
        private static Строка операцияПоУмолчанию = new Строка { Значение = "НайтиПоНомеру" };
        public ПримитивИлиАдрес ИмяОбъекта; //диспетчер по умолчанию - статическое или (строка или Адрес)
        public ПримитивИлиАдрес ИмяОперации; // найти по имени по умолчанию - статический метод
        private Строка _имяОперации
        {
            get
            {
                if (ИмяОперации is Строка)
                {
                    return (Строка)ИмяОперации;
                }
                else
                {
                    return (Строка)((Адрес)ИмяОперации).АдресВКуче();
                }
            }
        }
        public List<ПримитивИлиАдрес> СписокПараметров; // например текстовое имя, вместо строки это может быть другой объект или адрес

        public override ПримитивИлиАдрес АдресВКуче() // в данном случае объект находиться в памяти, получается адрес объекта в памяти которому потом можно будет отдавать команды
        // получение объекта нужно только для отдачи команд, сам объект не нужен, кроме случая удаленного объекта
        // тогда получеение объекта можно расценивать как начало установления сессии 
        // это также может быть открытый файл
        {
            Type t;
            object p = null;
            if (ИмяОбъекта is Строка) // это тогда статический 
            {
                t = Type.GetType(((Строка)ИмяОбъекта).Значение);
                p = t.InvokeMember(name: _имяОперации.Значение, invokeAttr: BindingFlags.InvokeMethod,
                            binder: null, target: null, args: СписокПараметров.ToArray());

            }
            else
            {
                var посредник = ((Адрес)ИмяОбъекта).АдресВКуче();
                p = посредник.GetType()
                       .InvokeMember(name: _имяОперации.Значение, invokeAttr: BindingFlags.InvokeMethod,
                           binder: null, target: посредник, args: СписокПараметров.ToArray());
            }


            return (ПримитивИлиАдрес) p;

        }

        public object ВыполнитьКоманду(string имяМетода, params object[] параметры)
        {
            return null;
        }
        //public ОбъектУдаленный Объект;
        public string[] ПолучитьСписокМетодов()
        {
            //первой строкой добавить создать новый адрес- получается функциональное программирование имя метода также вычисляется
            return null;
        }
        public string[] ПолучитьСписокПараметров(string имяМетода)
        {
            return null;
        }

    }

    public class ДоступКФайлу
    {
        public string ИмяФайла;
        public int ВернутьБайтПоНомеру(int номер)
        {
            var f = File.Open(ИмяФайла, FileMode.Open);
            f.Position = номер;

            return f.ReadByte();
        }

    }

    public class ОбъектУдаленный : ПримитивИлиАдрес //посредник общения с объектом
    {
        public Адрес АдресОбъекта;
        private object _быстрыйАдрес; // это может быть адрес в памяти - Постоянный КАНАЛ
        public object ПолучитьБыстрыйАдрес() { if (_быстрыйАдрес == null) _быстрыйАдрес = АдресОбъекта.АдресВКуче(); return _быстрыйАдрес; }
        public object ПолучитьЗначениеПоля(string имя)
        {
            if (_быстрыйАдрес == null) _быстрыйАдрес = АдресОбъекта.АдресВКуче();
            return _быстрыйАдрес.GetType().GetField(имя);

            return null;
        }
        public object УстановитьЗначениеПоля(object имя, object значение)
        {
            return null;
        }
        public object ВыполнитьКоманду(params object[] параметры)
        {
            return null;
        }
        public string[] ПолучитьСписокПолей()
        {
            return null;
        }
        public string[] ПолучитьСписокМетодов()
        {
            return null;
        }
    }
}
