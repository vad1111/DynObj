using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Динамические
{
    // эта активность базовая она составляет пространство имен, просто запоминает полученную информацию, ищет похожую и если нет добавляет
    // под это подходит Слово, Алфавит, пространство имен XML (здесь проще создается только в открывающем теге одно имя, потом ищется закрывающий  , 
    public class ПространствоИмен : Активность
    {
        public List<object> Множество;
        public List<ИменованнаяГруппа2> МножествоСписков; //если это список слов 
        public List<object> РеакцииОбъектов; // это уже полноценный Словарь элемент значение, т.е. это значение элемента списка, хотя в именоваанойГРуппе можно сохраанить и реакцию, кто ее будет запускать?
        public int ТекущийИндекс;
        public List<ИменованнаяГруппа2> СписокПодходящихОбъектов; // 
        public ИменованнаяГруппа2 ТекущийОбъектСписок; // это может быть в шаблоне Слова И проверка на выход и блок добавления тоже, возможно добавлять и нельзя это законченное множество 
        private bool _режимДобавления;
        public override void ПолучиСообщение(Связь связь, ПримитивИлиАдрес сообщение)
        {
            // если сообщение просто символ или адрес объекта
            if(Множество.Contains(сообщение)) return;
            Множество.Add(сообщение);

            // если получаются сообщения интерактивно по одному символу
            var объект =  сообщение;
            if (объект == null) // сигнал завершения 
            {
                if (_режимДобавления)
                {
                    //событие добавлен новый список объектов
                    МножествоСписков.Add(ТекущийОбъектСписок); //если список отсортирован, можно вставить в нужное место
                    ОтослатьСообщениеВсемИсходящим(ТекущийОбъектСписок); // отправиться только адрес
                }
                else
                {
                    // у нас есть список подходящих, объект с совпадающей длиной и есть совпадение ( в отсортированном должен быть первым элементом)
                    var длинаОбъекта = ТекущийОбъектСписок.Count;
                    var номерПодходящего = -1;
                    for (int i = 0; i < СписокПодходящихОбъектов.Count; i++)
                    {
                        if (длинаОбъекта == СписокПодходящихОбъектов[i].Count)
                        {
                            номерПодходящего = i;
                            ТекущийОбъектСписок = СписокПодходящихОбъектов[i];
                            // событие найден подходящий объект - т.е. список реакций не пустой 
                            ОтослатьСообщениеВсемИсходящим(СписокПодходящихОбъектов[i]);
                            break;

                            // обнулить все и выйти
                        }
                    }
                    if (номерПодходящего == -1) //все подходящие длиннее
                    {
                        МножествоСписков.Add(ТекущийОбъектСписок); //если список отсортирован, можно вставить в нужное место
                        //событие добавлен новый список объектов
                        ОтослатьСообщениеВсемИсходящим(ТекущийОбъектСписок);
                    }

                }

                _режимДобавления = false;
                ТекущийИндекс = 0;
                СписокПодходящихОбъектов = null;
                ТекущийОбъектСписок = null;
                return;
            }
            if (ТекущийИндекс == 0)
            {
                СписокПодходящихОбъектов = МножествоСписков;
                ТекущийОбъектСписок = new ИменованнаяГруппа2(){ИмяГруппы = "Имя Этого Словаря"};
            }

            ТекущийОбъектСписок.Add(объект);
            if (!_режимДобавления)
            {
                СписокПодходящихОбъектов = НайтиПодходящиеПоТекущемуИндексу(объект);
                if (СписокПодходящихОбъектов.Count == 0) //нет ни одного подхлдящего - сброс поиска
                {
                    _режимДобавления = true;
                    //повторить поиск для нуля Это для поиска подстроки
                }
                // посыл промежуточных результатов
                ОтослатьСообщениеВсемИсходящим(СписокПодходящихОбъектов);// если режим добавления запрещен и подходящий только 1 можно предположить что набираемый список именно этот
            }

            
        }

        public List<ИменованнаяГруппа2> НайтиПодходящиеПоТекущемуИндексу(object объект)
        {
            var СписокПодходящихОбъектов2 = new List<ИменованнаяГруппа2>(); //для сортированного списка можно просто получать диапазон адресов 
                for (int и = 0; и < СписокПодходящихОбъектов.Count; и++)
                {
                    var элемент = МножествоСписков[и];
                    if (элемент[ТекущийИндекс] == объект)
                    {
                        СписокПодходящихОбъектов2.Add(элемент);// лучше вычитать неподходящие объекты
                        ТекущийОбъектСписок.Add(элемент);
                    }
                }
                
            return СписокПодходящихОбъектов2;
        }
    }

    

}
