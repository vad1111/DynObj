using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Динамические.активности.распознование
{

    public class Запоминание: Псевдоактивности
    {
        private object память;
        public bool Обучение; // это сигнал на обучение  присвоение включает/выключает обучение

        //Реакция на сигнал
        public override void Получи(object сигнал)
        {
            if(Обучение) память = сигнал;

            Сравнить(сигнал);
        }

        // обучение
        public void Запомнить(object сигнал)
        {
            память = сигнал;
        }
        // 
        public int Сравнить(object сигнал)
        {
            if (Equals(память, сигнал))
            {
                Отправить(1); return 1;
            }
            else
            {
                Отправить(0);return 0;
            }
        }

      
    }

    public class Максимум : Псевдоактивности
    {
        public int Результат;

        public void Добавить(int сигнал)
        {
            Результат = Math.Max(Результат, сигнал);
        }
    }
    public class Минимум : Псевдоактивности
    {
        public int Результат;

        public void Добавить(int сигнал)
        {
            Результат = Math.Min(Результат, сигнал);
        }
    }

    public class НейроСеть   //Куча Нейронов
    {
        public List<Псевдоактивности> Пространство= new List<Псевдоактивности>();
        public List<Псевдоактивности> Входящие = new List<Псевдоактивности>();
        public List<Псевдоактивности> Результирующие = new List<Псевдоактивности>();
        public List<Псевдоактивности> Скрытые = new List<Псевдоактивности>();
        // слои как бы выделить, входящая, результрующая, скрытый = модель реальности
        public Action Обучить; //
        public Action Использовать; //
    }

    public class Тесты
    {
        // аналогично кусок экрана
        void СравнениеСтрок(string строка1, string строка2)
        {
            // создание сети
            var слой1 = new Запоминание[100];
            var минимум = new Минимум();
            foreach (var нейрон in слой1)  //100 связей
            {  нейрон.СоздатьСвязьС(минимум, ТиНапрвления.Исходящая); }

            var  сеть = new НейроСеть();
            сеть.Пространство.AddRange(слой1);
            сеть.Пространство.Add(минимум);

            // обучение
            void Обучение(string входнаяСтрока)
            {
                for (var index = 0; index < входнаяСтрока.Length; index++)
                {
                    слой1[index].Запомнить( входнаяСтрока[index] );
                }
            }
            Обучение(строка1);
            
            // после обучения можно зафиксировать память установив у всех режим обучения false
            // можно добавить у всего слоя1 еще входящую ссылку РежимОбучения
            // либо создать Метод у слоя ВклВыкл обучение, это аналог добавки нейромедиаторов

            // сравнение
            for (var index = 0; index < строка2.Length; index++)
            {
                char c = строка2[index];
                минимум.Добавить(слой1[index].Сравнить(c));
            }
            // выход в результате  строка2 может быть подстрокрй строка1
            var рез = минимум.Результат;

        }

        // сравнение двух изоюражений, строк и выдача только разницы, вычитание двух множеств
        // слой1 запоминание, слой2 запоминание(здесь разница) слои связаны паралельно
        // слой1 сравнивает память и сигнал, возвращает новый сигнал слой2, на слой3 старый сигнал
        // слой2 = добавление нового, слой3 - удаление старого
        // каждый такт даст на слое2 только движение появление нового 
        // слой3  исчезновение предыдущего момента
        // если изменений нет, слой2и 3 будут пусты 
        // если движется светлый круг по экрану, то виден будет один полумесяц в слое2 и обратный слой3
        // соединение крайних точек выделит объект и покажет направление 
        // если есть 2 движущихся объекта, то направление 2вух,если 
        //ввести фокус то можно сократить вычисления, на кждый объект по фокусу
        // что не в фокусе = фон, фокусом можно считать слой2+слой3, но там сразу несколько  объектов
        // фокус это фильтр 


         //обучение - классификация - если строка1 не совпадает со строой2 запомнить строку 2 и т.д.
        // так будут накапливаться куча слоев никак не связанных 

    }


}
