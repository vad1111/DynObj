using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Динамические
{
    public class ДисковоеХранилище : Примитив
    {
        private  byte длинаАдреса = 4; // длина в байтах
        public  string ИмяФайла = "";
        public int СчетчикОбъетов;
        private byte адресСчетчика;
        private BinaryWriter Писатель;
        private BinaryReader Читатель;
        private  int длинаФайла;
        private BinaryWriter ПисательУдаленные; //если каждый раз создается новый файл, то не нужен
        private BinaryReader ЧитательУдаленные;

        public List<int> ИндексВпамяти; //при замене группы адрес объекта в Памяти не меняется, но меняется адрес в Файле
        public  BinaryWriter ПисательИндекса; //файл диспетчера удобен, чтобы не открывать все объекты, сами объекты могут в память даже  не загружаться это индексный файл
        public  BinaryReader ЧитательИндекса;

        public void Создать()
        {
           var поток= File.Create(ИмяФайла);
            Читатель = new BinaryReader(поток);
            Писатель = new BinaryWriter(поток);

            Писатель.Write("Дисковое Хранилище");
            Писатель.Write(длинаАдреса);
            адресСчетчика = (byte)Читатель.BaseStream.Position;
            Писатель.Write(СчетчикОбъетов);
            // индекс
            var потокИндекс = File.Create(ИмяФайла+".индекс");
            ПисательИндекса= new BinaryWriter(потокИндекс);
            ЧитательИндекса= new BinaryReader(потокИндекс);

        }
        public void Открыть() // можно запихать в конструктор
        {
            try
            {
                if (File.Exists(ИмяФайла))
                {
                    Stream поток = new FileStream(ИмяФайла, FileMode.Open, FileAccess.ReadWrite);
                    Читатель = new BinaryReader(поток);
                    Писатель = new BinaryWriter(поток);

                    Читатель.ReadString();//=хранилище
                    длинаАдреса = Читатель.ReadByte(); //длинаАдреса
                    адресСчетчика = (byte) Читатель.BaseStream.Position;
                    СчетчикОбъетов = Читатель.ReadInt32();

                    var потокИндекс = new FileStream(ИмяФайла + ".индекс", FileMode.Open, FileAccess.ReadWrite);
                    ПисательИндекса = new BinaryWriter(потокИндекс);
                    ЧитательИндекса = new BinaryReader(потокИндекс);
                }
                else
                {
                    Создать();
                }
                
            }
            catch (Exception)
            {

                throw;
            }

        }
        public override void СохранисьВ(BinaryWriter писатель)// это сохранение в центральном хранилище
        {
            писатель.Write(ИмяФайла);
        }
        public override ПримитивИлиАдрес Восстановить(BinaryReader читатель)
        {
            ИмяФайла = читатель.ReadString();
            Открыть();
            return this;
        }

        /// <summary>
        /// зависит ведется счетчик объектов или нет (-1 - количество не известно
        /// Первоначально из просмортщика может видется только количество объектов, дальше может запроситься первые несколько чтобы посмтреть, дальше листание, в память загружаются только видимые
        /// </summary>
        /// <returns></returns>
        public int КоличествоОбъектов() // 
        {
            return СчетчикОбъетов;
        }

        public override string ToString()
        {
            return "Дисковое Хранилище "+ ИмяФайла+ " ("+СчетчикОбъетов+ " объектов)";
        }

        public void ПрочитатьОбъектВПамять(int адрес, ГруппаОбъектов Память) //временное сохранение в памяти объекта
        {
            var объект = ПрочитатьОбъект(адрес);
            Память.Добавить(объект); // можно сохранить еще в хранилище это сохраняемый объект, а не временный, Память нужно в конце очищать или заводить отдельную группу с путым сохранением
        }

        public ПримитивИлиАдрес ПрочитатьОбъект( int адрес) //читает только первый уровень, не лезет разбирать адреса
        {
            Читатель.BaseStream.Position = адрес; //перместить указатель на адрес объекта
            var  прим = ПримитивИлиАдрес.Создать(Читатель.BaseStream);
            
            return прим;
        }

        public void Записать ( ПримитивИлиАдрес примитив, int адрес) // существует опасность перекрытия данных
        {
            Писатель.BaseStream.Position = адрес;
            //var кодТипа = Хранилище.кодыТипов[примитив.GetType()];
            // установить проверку если это АдресВФайле, и АдресДисковогоХранилища= АдресПримитива, то сохранить только номерВФайле
            // т.е. код типа должен быть другой = ВнутреннийАдрес
            //Писатель.Write(кодТипа);
            примитив.СохранисьВ(Писатель.BaseStream);

            Писатель.BaseStream.Position = адресСчетчика;
            СчетчикОбъетов++;
            Писатель.Write(СчетчикОбъетов);
        }
        public АдресВФайле ДобавитьВКонец (ПримитивИлиАдрес примитив) //добавить в конец файла
        {
            var адресБайта = (int)Писатель.BaseStream.Length;
            Записать(примитив, адресБайта); //установить указатель в конец и записать

            ПисательИндекса.BaseStream.Position = ПисательИндекса.BaseStream.Length; 
            ПисательИндекса.Write(адресБайта); // номер объекта по индексу* 4 = содержит 

            return new АдресВФайле() { НомерВФайле = адресБайта, СобственныйАдресПримитива = this.СобственныйАдресПримитива };

        }

        public ПримитивИлиАдрес ДайОбъектПоИндексу(ЦелоеЧисло номер)
        {
            ЧитательИндекса.BaseStream.Position = номер.Значение*4;
            var адресОбъекта = ЧитательИндекса.ReadInt32();
            Читатель.BaseStream.Position = адресОбъекта;

            var прим = ПримитивИлиАдрес.Создать(Читатель.BaseStream);
            return прим;

        }

        public void НаОбъектПоИндексу(ЦелоеЧисло индекс, ПримитивИлиАдрес объект)
        {
            ЧитательИндекса.BaseStream.Position = индекс.Значение * 4;
            var адресОбъекта = ЧитательИндекса.ReadInt32();
            Читатель.BaseStream.Position = адресОбъекта;
            int длинаОбъекта;
            длинаОбъекта = ЧитательИндекса.ReadInt32(); // вариант с записью длины в индекс
            // узнать длину сохраненного объекта, его тип
            var номерТипа= Читатель.ReadByte();
            
            var тип =  Хранилище.Типы[номерТипа];
            // для примитивов 
            
            длинаОбъекта = (int) тип.InvokeMember("Длина",BindingFlags.InvokeMethod, null,null, null );
            //для групп и строк
            длинаОбъекта = Читатель.ReadUInt16();

            // если тип объекта совпадает с типом сохраненного объекта и этот тип не группа = длины сохраненных объектов совпадают
           Записать(объект,адресОбъекта);
            // если ттип не совпадает
            // то сравнить длину , если длина совпадает, то ттоже записать
            
            // если длина не совпадает 
            //то найти подходящее место 
                // в файле с удалениями есть
            // запомниттьпустое место

            int новыйАдресОбъекта=0;
            // запомнить новый адрес в индексе
            ЧитательИндекса.BaseStream.Position = индекс.Значение * 4;
            ПисательИндекса.Write(новыйАдресОбъекта);
            Записать(объект,новыйАдресОбъекта);

            // записать в удаленных пусттое место адрес начала, длина, было бы не плохо отсортировать этот файл по длинам
            // еще вариант использовать 



        }

       

        // можно создать разреженный объект поток и распихать его в дыры
        public MemoryStream ЗаписатьВВиртуальныйПоток(ПримитивИлиАдрес примитив) // 
        {
            var виртПоток = new MemoryStream();
            var писатель = new BinaryWriter(виртПоток);
            var кодТипа = Хранилище.кодыТипов[примитив.GetType()];
            писатель.Write(кодТипа);
            примитив.СохранисьВ(Писатель);
            
            return виртПоток;

        }
        // как его использовать 
        public static void Тест()
        {
            
            var адресДХ= Хранилище.Добавить(new ДисковоеХранилище() { ИмяФайла = "имя" }); // теперь Дисковое хранилище может восстанавливается открываться
            var хр=((ДисковоеХранилище)адресДХ.АдресВКуче());
            хр.Открыть();

            var д = new ДисковоеХранилище() {ИмяФайла = "дисковое хранилище"};
            д.Создать();
            var адресЦелого = д.ДобавитьВКонец(new ЦелоеЧисло() {Значение = 10});
            var целое = д.ПрочитатьОбъект(адресЦелого.НомерВФайле);
            var адресСтроки2 = д.ДобавитьВКонец(new Строка() {Значение = "с"});
            var строкаПрочитнная = д.ПрочитатьОбъект(адресСтроки2.НомерВФайле);
            var адресСтроки3 = д.ДобавитьВКонец(new Строка() { Значение = "Строка" });

            var адресСтроки= хр.ДобавитьВКонец(new Строка() { Значение = "строка на диске" }); // строка не добавляется в Память, только на Диск
           

            Хранилище.Добавить(адресСтроки); // теперь можно по адресу добраться до самой строки
            
            //примитивы должны сохраняться вместе с адресом,иначе они будут потеряны, Дисковое хранилище можно полностью прочитать, последовательно и просмотреть все объекты
            // важна замена объекта по адресу, либо перезапись, либо перенаправление. Перезапись предполагает резервирование дополнительного места (байтов), перенаправление, должно содержать
            //новый адрес, который должен уместиться в старое пространство, т.е. строка не может быть меньше 4 байт(минимального адреса)


           
            var копияСтрокиВПамяти = адресСтроки.АдресВКуче();

            // теперь добавим адрес строки на диск
            var адресАдресаСтроки = хр.ДобавитьВКонец(адресСтроки); // теперь по этому адресу храниться (1.номер ДХ  в Хранилище и 2.номер строки в ДХ) 1 здеь лишниее
            //похоже адрес в файле не должен содержать адреса ДХ в хранилище- это уже  


            
            
        }

    }
}
