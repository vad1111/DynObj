using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Динамические
{
    public class Группа : ПримитивИлиАдрес
    {
        public virtual ПримитивИлиАдрес this[int индекс]
        {
            get { return null; }
            set { }
        }

        public virtual ПроксиОбъекта this[ Адрес адрес]
        {
            get { return null; }
            set { }
        }

        public virtual Адрес Добавить(ПримитивИлиАдрес объект)
        {
            return null;
        }
       
    }

    // Словарь это ГруппаОднотипныхОбъектов например букв (изображенийбукв)
    // кодовые таблицы как не странно не существуют есть таблицы изображений использующ ее, и описание 
    // есть еще СловариПреобразования связывающие две таблицы 
    // Тип объектов здесь адрес 
    // это в частности строка,
    // это группа типа ряд , вставка элемента также сообщает подписантам об изменеии, например видам что номер изменился 
    public class ГруппаАдресовИзСловаря : ГруппаОбъектов
    {
        public ГруппаТипизированная Перечисление;

        public ПроксиОбъекта ДайЭлементСловаря(Адрес адрес)
        {
            var элемент = ДайЭлемент(адрес, СобственныйАдресПримитива);
            // везде добавляется собственный адрес группы 
            // в списке владельцев будет куча одного и тогоже адреса группы - исправить
            // группа должна содержать реакцию на изменние словаря, нужно найти элементы адресом больше или равно изменяемого адреса и поменять их на единицу больше или меньше
            // если связь со словарем разорвана, то измения могут потеряться
            // врианты иметь локальную копию словаря и каждый раз сравнивать версию
            // редактирование словаря приводит к созданию новой копии и таблицы изменения
            // изменения: удален элемент с номером, изменен адрес того же алемента, новый элемент
            // если эменты сложные например группа и поменялась группа, замена

            return элемент;
        }
    }

    // Еще тип словаря когда обе группы ключи , т.е. объект не повторяется И возможен поиск в обе стороны

    public class ГруппаОбъектов : Группа , IEnumerable<ПримитивИлиАдрес>
    {
        public List<ПримитивИлиАдрес> Список =new List<ПримитивИлиАдрес>(); 
        List<List<Адрес>> СписокВладельцевЭлементов = new List< List<Адрес>>();

        public override ПримитивИлиАдрес this [int индекс] {
            get
            {
                var примитив = Список[индекс];
                //примитив.СобственныйАдресПримитива = new АдресВГруппе() { АдресРегистратора = СобственныйАдресПримитива, АдресГруппыВкуче = this, НомерВГруппе = индекс }; //уже создан в Добавить и сетере

                return примитив;
            }
            set
            {
                Заменить(индекс,value);
            }

        }

        public  ПроксиОбъекта ДайЭлемент (int индекс , Адрес адресВладельца) // дается копия элемента 
        {
            var  элемент = new ПроксиОбъекта();
            элемент.АдресПримитива = (Адрес) Список[индекс].СобственныйАдресПримитива.Копировать();
            //элемент.Примитив = Список[индекс].Копировать();

            СписокВладельцевЭлементов[индекс].Add(адресВладельца);
            //Подписать на изменеия значения, адреса, значения примитива

            return элемент ;
            
        }
        public ПроксиОбъекта ДайЭлемент(Адрес адрес, Адрес адресВладельца) // дается копия элемента 
        {
            var индекс = ((АдресВГруппе) адрес).НомерВГруппе;
            var элемент = new ПроксиОбъекта();
            элемент.АдресПримитива = (Адрес)Список[индекс].СобственныйАдресПримитива.Копировать();
            //элемент.Примитив = Список[индекс].Копировать();

            СписокВладельцевЭлементов[индекс].Add(элемент.СобственныйАдресПримитива);
            //собственный адрес элемента еще не определен, указывается адрес в Куче адреса
            //Подписать на изменеия значения, адреса, значения примитива

            return элемент;

        }



        public void Вставить(int номер, ПримитивИлиАдрес объект) // вставка меняет адреса всех нижних элементов и копии этих объектов будут иметь неправльный адрес
            // если группа отдала копию объекта, то объект становиться самостоятельным и надо пометить его внутри что он связан и его адрес менять нельзя, вставки выше него не возможны 
            // или в этой группе надо завести новую группу или на место объекта поместить новую группу со старым значением
            // или выдавать новому владельцу, целую оболочку,запоминать кому отдал, чтобы в случае смены адреса отослать сообщение о смене адреса 
            // можно сделать кучу с объектами, и отдельную группу в виде связанного списка , объект будет хранить номер следующего и предыдущего
            // вставка это будет добавление в конец кучи, и смена адресов между в месте вставки + нужна группа для быстрого доступа 
        {
            Список.Insert(номер,объект);
            
            объект.СобственныйАдресПримитива = new АдресВГруппе() { АдресРегистратора = СобственныйАдресПримитива, АдресГруппыВкуче = this, НомерВГруппе = номер };

            //  менять все нижележащие элементы, собственные адреса элементов
            for (int и = номер + 1; и < Список.Count; и++)
            {
                var элемент = Список[и];
                
                ((АдресВГруппе)элемент.СобственныйАдресПримитива).НомерВГруппе++;
                // сообщить подписчикам Изменился элемент 
            }
        }

        public void Удалить(int номер)
        {
            Список.RemoveAt(номер);
            for (int и = номер ; и < Список.Count; и++)
            {
                var элемент = Список[и];
                ((АдресВГруппе)элемент.СобственныйАдресПримитива).НомерВГруппе--;
                // сообщить подписчикам Изменился элемент 
            }
        }
        public override ПримитивИлиАдрес Копировать()
        {
            var копия = new ГруппаОбъектов();
            foreach( ПримитивИлиАдрес элемент in Список)
            { копия.Добавить(элемент.Копировать());} // нельзя добавить значение адреса может быть цикл 
            return копия;
        }

        public void Add(ПримитивИлиАдрес примитив)
        {
            Добавить(примитив);
        }

        public override Адрес Добавить(ПримитивИлиАдрес объект)
        {
            Список.Add(null); // в многопоточном будет проблема может быть создано несколько пустых одновременно и заменить получит другой Count
            СписокВладельцевЭлементов.Add(null);
            return Заменить(Список.Count-1,объект);
        }

        public Адрес Заменить(int номер, ПримитивИлиАдрес объект)
        {
            var  адрес= new АдресВГруппе()
            {
                АдресРегистратора = СобственныйАдресПримитива,
                АдресГруппыВкуче = this,
                НомерВГруппе = номер
            };
            //if (объект is Группа) // возможно собственный адрес нужно добавлять только группам
            //{
            //}
            объект.СобственныйАдресПримитива = адрес;

            Список[номер] = объект;
            //СписокВладельцевЭлементов.Add(null);

            // известить Элементы
            if (СписокВладельцевЭлементов[номер]!=null)
            foreach (var адресВладельцы in СписокВладельцевЭлементов[номер])
            {
               ((ПроксиОбъекта) адресВладельцы.АдресВКуче()).ИзменитьИздалека(объект);
            }

            return адрес;
        }


        public bool Заменить(Адрес адрес, ПримитивИлиАдрес новоеЗначение)
        {
            var адр = адрес as АдресВГруппе;
            if (адр == null) return false;

            Список[адр.НомерВГруппе] = новоеЗначение;
            return true;
        }

        public override void СохранисьВ(BinaryWriter писатель)
        {
            base.СохранисьВ(писатель);
            писатель.Write(Список.Count); //длина списка
            foreach (var примитивИлиАдрес in Список) // все адреса
            {
                примитивИлиАдрес.СохранисьВ(писатель);
            }
        }

        public override ПримитивИлиАдрес Восстановить(BinaryReader читатель)
        {
            var длина = читатель.ReadInt32();
            for (int i = 0; i < длина; i++)
            {
                ПримитивИлиАдрес примитив = ПримитивИлиАдрес.Создать(читатель.BaseStream);
                Добавить(примитив);
            }
            return this;
        }

        public IEnumerator<ПримитивИлиАдрес> GetEnumerator()
        {
            return Список.GetEnumerator();
        }

        public override string ToString()
        {
            var строка = "";
            var l = Math.Min(4, Список.Count);
            for (byte i = 0; i < l; i++)
            {
                строка += Список[i] + ",";
            }
            return СобственныйАдресПримитива + " Группа (" + Список.Count + ") : {" + строка + "}";
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    
    public class ГруппаТипизированная : ГруппаОбъектов
    {
        //public ГруппаОбъектов Список;
        public Type ТипХранящихсяОбъектов {get { return СписокТипов[НомерТипа]; } set
        {
                if(НомерТипа!=0)
            НомерТипа =  Хранилище.кодыТипов[value]; // менять тип элементов нельзя
        } } 
        //= тип возврата, тип добавления
        public int НомерТипа; // тут может быть список номеров - тогда это будет перечисление и спиоок списков 
                                // могут быть проблемы с воостановлением, Список типов может измениться 
        public List<Type> СписокТипов = Хранилище.Типы;
        //public override Адрес Добавить(ПримитивИлиАдрес объект) // требуется еще поменять индексер
        //{
        //    if (объект.GetType() == ТипХранящихсяОбъектов)
        //    {
        //       return base.Добавить(объект);
        //    }
        //    else
        //    {
        //        return null;
        //    }
        //}
    }


    // это похоже на входящий фильтр для операций присвоения 
    public class ГруппаИзПеречисленныхТипов : ГруппаОбъектов
    {
        public List<Type> ПеречмслениеТипов;
    }
}
