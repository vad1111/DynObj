using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Динамические
{
    public class КлассCSharp : ПримитивИлиАдрес //Описание Структуры типа База данных = фиксированный список полей, 
        //добаления или удаление полей создает обратную несовместимость с существующими экземплярами
        // создание типа(КЛАССА) в процессе обучения происходит наоборот экземпляры по схожести структуры объдиняются в группу 
    {
        public Строка Имя; // ссылка это " эта группа имеет имеет имя ИИИИ 
        public ГруппаОбъектов ОписанияПолей; // это шаблон по которому создается экземпляр класса
        public ГруппаОбъектов Команды;

        public АдресВХранилище СоздатьЭкземплярКласса()
        {
            var адресЭкземпляра = ОписанияПолей.Копировать();
            var экз = new ЭкземплярКласса();
            экз.АдресКласса = СобственныйАдресПримитива;
            экз.Поля = new ГруппаОбъектов();
            экз.Поля.Список.Capacity = ОписанияПолей.Список.Count; // ограничение списка 
            return new АдресВХранилище(){}; // этот адрес не добавлен в хранилище
        }

        public static ПримитивИлиАдрес  СоздатьТип( Строка ИмяКласса)
        {
            var класс = new ГруппаОбъектов();
            
            var пара = new ГруппаОбъектов();
                пара.Добавить(new АдресВХранилище(){НомерВХранилище = 1}); // Хранилище.Найти( "Имя") - это индекс фиксированный
                пара.Добавить(ИмяКласса); // здесь содержиться имя класса-  
            класс.Добавить(пара);
            return класс;

            // скопировать пару можно, но дорого 
        }

        static КлассCSharp()
        {
            //создать группу типов 
            // группа типов состоит из пар( ИмяТипа, адрес ОписанияТипа)
            // как найти адресОписания 
            // в группе слов найти адрес искомого слова
            // группаТипов.Найти просмотреть все пары= если (первый член == искомому имени), то вернуть второй член 
            // группа состоит из адресов
            // смотриться первый адрес, если это слово "команда" запускается метод, который берет имя из первого,  аргументы из второго адреса, возвращает в третий адрес
            // справочник методов в статическом словаре для простых методов типа "ВыполнитьПоследовательность методов" = если это метод -выполнить, группа содержит уже список адресов и примитивов
            // можно сделать примитив команда, который будет сразу выполняться !!!не стоит усложнит перенос проще проверить нулевой член группы, э тогда числа тоже придется составлять из групп
            // 

            var группаТипов= new ГруппаОбъектов();
            группаТипов.Добавить(Строка.Создать("Тип")); // это группа адресов
            var адресГруппыТипов =  Хранилище.Добавить(группаТипов);



        }

        

    }

    public class ЭкземплярКласса //этот объект относиться (является экземпляром) к  типу (= группа имеющих общуую структуру полей) объектов
    {
        public Адрес АдресКласса;
        public ГруппаОбъектов Поля; // Это группа создается по шаблону из описанийГруппы
    }

    public class Поле
    {
        public Строка Имя;
        public АдресВХранилище типДоступа;
        public АдресВХранилище Значение;

    }

    // более простой вариант создания собственных типов
    public class Класс
    {
        public string Имя;
        public Dictionary<string, object> ПоляИлиМетоды;
        public ГруппаОбъектов Свойства;

        public static void Тест()
        {
            var класс= new Класс(){Имя = "Пробный"};

            класс.ПоляИлиМетоды.Add("Поле1", new object());
            класс.ПоляИлиМетоды.Add("Метод", new План());
            класс.ПоляИлиМетоды.Add("Метод2", new Сложение());

            класс.Свойства[0]= new Строка("Имя класса");
            var поле1 = new ГруппаОбъектов();
            класс.Свойства[1] = поле1;
            поле1[0]= new Строка("это Поле");
            поле1[1] = new Строка("имяПоля1");
            поле1[2] = new Строка("ТипаЗначения"); //может быть не опрееделен, может иметь группу типов
            поле1[3] = new Строка("ЗначениеПоля");

            var класс2= new ГруппаОбъектов();// это класс
            класс2[0]= new Строка("Это тип объектов"); // или адрес на строку что это Тип. Описание типа это группа которая может иметь группу полей и группу методов
            класс2[1] = new Строка("Имя типа (Целое)"); // имеет имя 
            класс2[2] = поле1; // имеет поле

            var тип = new ГруппаОбъектов();
            var адресОписанияТипов = Хранилище.Добавить(тип);
            тип[0]= new Строка("Это описание типов");
            тип[1] = new Строка("имеет список полей (создать ГруппуОбъектов с именем список полей)"); ; // это список полей
            ((ГруппаОбъектов)тип[1])[0]= new Строка("это список полей");
            тип[2] = new ГруппаОбъектов(); // это список методов
            ((ГруппаОбъектов)тип[2])[0] = new Строка("это список методов");

            //клонирование типа
            // создать новый тип
            var класс3 = new ГруппаОбъектов();
            класс3[0] = адресОписанияТипов;
            for (int индекс = 1; индекс < тип.Список.Count; индекс++)
            {
                класс3[индекс] = тип[индекс].Копировать();
            }


            var локальныйСписокТипов = new ГруппаОбъектов(); // сюда добавляются типы
            локальныйСписокТипов[0] = new Строка("Это локальный список типов");
            локальныйСписокТипов.Добавить(класс2);



          

            var матрицаТипа = new ГруппаОбъектов();
            var адресматрицы = Хранилище.Добавить(матрицаТипа);
            матрицаТипа[0] = new Строка("это матрица тип");
            матрицаТипа[1] = new Строка("Имя типа");
            матрицаТипа[2] = new ГруппаОбъектов(); ; // это список полей
                        ((ГруппаОбъектов)матрицаТипа[2])[0] = new Строка("это список полей");
            матрицаТипа[3] = new ГруппаОбъектов(); // это список методов
                        ((ГруппаОбъектов)матрицаТипа[3])[0] = new Строка("это список методов");
            матрицаТипа[4]= адресматрицы; //new Строка("Здесь должен быть адрес матрицы");

            var класс4 = (ГруппаОбъектов) матрицаТипа.Копировать(); //клонировать это копирование структуры, но не значений, здесь это клонирование 

            класс4[0]= матрицаТипа; // в 0 хранится родитель

            var адресКласс4 = СоздатьТип("Бар"); // создание без матрицы

            На_ИмяТипа(класс4, new Строка("Бар")); // 

            Класс.ДобавитьПоле(адресКласс4, Класс.СоздатьПоле( "ЦенаОткрытия",  new АдресВХранилище()));
            
            var экземпляр = Класс.СоздайЭкземплярКласса(класс4);
            
            var значениеПоля = Класс.ДайЗначение( экземпляр,"ЦенаОткрытия");

            // выделение в независимый объект это перемещение из группыОбъектов в Хранилище (или другую группу) 
            // вместо объекта там появляется адрес объекта 
            // включение в группуобъектов означает что команды посылаются от группы к членам, но не оборот 
            // часть объектов может быть помечена как некопируемая
            // команды всегда отдаются активности(процессору), данные пассивны Процессор Сформируй (рез)бар (вход данные) из списка тиков за интервал И
            // (кому) список тиков (команда)( сформируй (рез) бар ) (параметр) за интервал - Это не корректное выражение, может (активнсть хранящая тики) правильно
            // (рез)бар (ком=страдательый залог) сформируйся (параметр) из списка тиков (парметр) за интервал И - здесь бар превращается в живое существо
            // в проге мы оперируем экземплярами: бар это сокращение от бар бар1 В определении достаточно бар, при исполнении получается конкретный бар1
            // все ООП бред!!!
            // програмирование надо вести в форме диалогов , т.к.
            // бар невсегда получается в форме результата, может быть и ошибка, программа всегда пишется будто нет ошибок 

            var метод = new ГруппаОбъектов
            {
                [0] = new Строка("метод"),
                [1] = new Строка("Имя метода"),
                [2] = new ГруппаОбъектов(), //определение параметров Параметры иогут иметь ссылки на этот метод и название у метода тогда меняется 
                [21] = new Адрес(), // адрес типа , там еще есть параметры или конкретного экземпляра данные там                   
                [3] = new ПримитивИлиАдрес(), // определение типа результата
                [4] = new АппаратноеДействие() // список действий 
            };
            // метод состоит из имени, списка параметров, возврат значений, список действий
            // один из параметров адрес экземпляра типа, все специальные параметры владеют этим методом (целое число как правило не является владельцем методов)
            // определение метода сигнатура


            
            var действие = (План) метод[4]; //=Действие
            
            действие.Выполнить(null);// сдесь в качестве параметра надо задавать список аргументов

            //Создание новой модели (Группы методов и описаний структуры - должна быть замкнутая структура, полная подмена , нужно использовать только ее)
            // эти методы применимы только к данной структуре 
            // эти методы позволяют убрать самоописание из структуры, т.к. заранее знают, что где
            // это еще перевод в понятные для внутреннего процесора команды
            // ЭТО ЕЩЕ ДАННЫЕ ДЛЯ ПРЕПРОЦЕССОРА который сжимает данные заменяет имена на адреса, 
            //                                          проводит проверку соотвествия типов после чего выкидывает их из методов, 
            //                                          заменяет вычислимые данные результатами

            var модель = new ГруппаОбъектов
            {
                [0] = new АппаратноеДействие() { Метод = typeof(Класс).GetMethod("СоздатьТип"), Имя = new Строка("Создать тип")},
                [1] = new АппаратноеДействие() { Метод = typeof(Класс).GetMethod("ЧтоЭто") },
                [2] = new АппаратноеДействие() { Метод = typeof(Класс).GetMethod("Дай_ИмяТипа") },
                [3] = new АппаратноеДействие() { Метод = typeof(Класс).GetMethod("СоздатьПоле") }, 
                [4] = new АппаратноеДействие() { Метод = typeof(Класс).GetMethod("СоздатьЭкземплярТипа") },
                [5] = new АппаратноеДействие() { Метод = typeof(Класс).GetMethod("ПрисвоитьЗначениеПолюЭкземпляра") },
                [6] = new АппаратноеДействие() { Метод = typeof(Класс).GetMethod("ВыполнитьМетод") }
            };

            // Описание сценариев общения (шаблон диалога)- метод программирования 
            // А: Вася? - установление связи
            // Б: Да        / Нет                   /Ну
            // А: Ты кто?   /Пардон, конец связи    / Что ну?
            // Б: бот                               /Ну Вася
            

           

            
        }

        public static void ВыполнитьМетод(ГруппаОбъектов метод)
        {
            var действия = (План) метод[4];
            действия.СписокЗначенийПеременных.AddRange(((ГруппаОбъектов) ((ГруппаОбъектов)метод)[2]).Список);
            метод[3]= (ПримитивИлиАдрес) действия.Выполнить(null);

        }
        //возврат должен быть адрес 
        // это описание типа или описание экземпляров типов
        // список методов одинаков для всех экземпляров 
        public static Адрес СоздатьТип(string имя)
        {
            var Тип = new ГруппаОбъектов
            {
                [0] = new Строка("тип"), //это общее для группы схожих объектов , если объекту задать вопрос (провести измерение) объект переадресует этот вопрос к этому адресу
                [1] = new Строка(имя),      // это по сути описание словосочетания и одновременно матрица для экземпляров типа (объектов)
                [2] = new ГруппаОбъектов {[0] = new Строка("список полей") }, // это список полей "имеет" эта группа типа "список" т.е. содержит однотипные объекты типа "поле", т.е. тип "поле" можно убрать
                [3] = new ГруппаОбъектов {[0] = new Строка("список методов") } // это список методов "имеет"
            };
            // создание Списка например типов, позволяет исключить [0]-ой элемент(самоописания), добавление туда группы авоматом делает ее "типом",это группа (самого типа) без самописания
            // Куча C# это группа экземпляров. И есть отдельная группа типов
            // это метод минимизации ресурсов, выделение общего объекта и объединение в группу с усечением общего элемента 

            return Хранилище.Добавить(Тип);
        }

        // структуры
        //     ГруппаОбъектов состоит из объектов произволной структуры (нет никаких ограничений)
        //      ГруппаПеречисление состоит из объектов нескольких структур (содержит группу перечисления)
        //      ГруппаСтруктуры каждая позиция имеет определенный тип
        //      ГруппаНечеткойСтруктуры, это взаимоисключающие объекты, могут повторяться только 1 раз в произвольном порядке
        //      ГруппаСогласования (типа словосочетания (сущ, муж), (прил, муж) это группа (муж) ( сущ, прил)
        //      1.СПисок это группа в которой определен тип элементов (и тогда объекты называются элементами и все элементы имеют одинаковую структуру)
        // 2.Синонимы это список взаимозаменяемых объектов 
        // 3 Антонимы это список взаимоисключающих объектов или группа 

        // аналог toString()
        public static ПримитивИлиАдрес ЧтоЭто(ГруппаОбъектов объект, ГруппаОбъектов интерпритация) 
            // для разных объектов будет разный метод, экземпляр, + это "Группа объектов" которая содержит список объектов
                                                                     // то что это "тип" это особая интерпритация, которая задается определенной группой методов и структурой 
                                                                     // должно быть 2 группы интерпритаций и 2 метода "ЧтоЭто" относительно 1-ой это группа, 2-ой это тип 
                                                                     // структуру можно преобразовать в группу методов 
            //фиксация структуры и связанных с ней методов создают новую модель реальности (например объектов)
        {
            var ответ = new ГруппаОбъектов
            {
                [0] = new Строка("Что это?"), // это описание или запрос от кого пришло, что пришло.
                [1] = new Строка("Это "),
                [2] = (Строка) объект[0]   // ответ "это тип" , вопрос чего? имя типа? с другой стороны это группа объектов 
            };

            return ответ;   // здесь должна быть не строка а словосочетание или что-то более длинное, целое описание , разные языки
                                        // каждый объект может определять свое описание
                                        // в общем случает это адрес метода, как получить ответ на этот вопрос
                                        // этот метод для простейшего случая 
        }
        public static void На_ИмяТипа(ГруппаОбъектов класс, Строка имяТипа)
        {
            if( класс[0]== new Строка("тип")) // не корректое сравнение исправить, присваивает имя только типам 
           класс[1]=имяТипа;
        }
        public static Строка Дай_ИмяТипа(ГруппаОбъектов класс)
        {
            return (Строка) класс[1] ;
        }
        public static ГруппаОбъектов СоздатьПоле(string имя, Адрес адресТипаПоля) //адрес типа поля 
        {
            // это описание поля
            var поле = new ГруппаОбъектов
            {
                [0] = new Строка("поле"),
                [1] = new Строка(имя),
                [2] = адресТипаПоля,
                [3] = new Строка("Значение")// это значение нужно только для объекта с полным самоописанием, значение поля экземпляра содержиться в экземпляре
            };
            // лучше указать адрес (адрес справочника, номер строки)
            // поле "принадлежит" типу или экзепляру 
            
            return поле;
        }

        public static void ДобавитьПоле( Адрес адресКласса, ГруппаОбъектов поле)
        {
            var класс = (ГруппаОбъектов)адресКласса.АдресВКуче();
            // проверить что класс это класс
            // что поле это поле
            ((ГруппаОбъектов)класс[2]).Добавить(поле);
        }

        public static ГруппаОбъектов СоздайЭкземплярКласса(ГруппаОбъектов класс)
        {
            var экземпляр = new ГруппаОбъектов();
            экземпляр[0] = new Строка("экземпляр типа (адрес типа имя)");// это группа словосочетания 0=экземмпляр, 1 = вычисление (адрес типа- адрес имени типа)
            экземпляр[1] = класс;  // так можно найти тип
            //экземпляр содержит только значения полей
            экземпляр.Список.Capacity = ((ГруппаОбъектов)класс[2]).Список.Count; // пустые первое поле начинается с 1 
            return экземпляр;
        }

        public static ПримитивИлиАдрес ДайЗначение(ГруппаОбъектов экземпляр, string имяПоля)
        {
            var класс = (ГруппаОбъектов)экземпляр[0];
            for (int i = 1; i < ((ГруппаОбъектов)класс[2]).Список.Count; i++)
            {
                if (((Строка) ((ГруппаОбъектов) ((ГруппаОбъектов) класс[2])[i])[1]).Значение == имяПоля)
                    return экземпляр[i];
            }
            return new Пустота();

        }

        //тоже можно сделать по номеру поля а не имени
        public static ПримитивИлиАдрес НаЗначение(ГруппаОбъектов экземпляр, string имяПоля, ПримитивИлиАдрес значение)
        {
            var класс = (ГруппаОбъектов)экземпляр[0];
            var типЭкземпляраЗначения =  ((ГруппаОбъектов) значение)[0]; //значение предполагается что это экземпляр класса
            var имяТипа =( (ГруппаОбъектов)типЭкземпляраЗначения)[1];

            for (int i = 1; i < ((ГруппаОбъектов)класс[2]).Список.Count; i++)
            {
                if (((Строка) ((ГруппаОбъектов) ((ГруппаОбъектов) класс[2])[i])[1]).Значение == имяПоля)
                {
                    // можно добавить прроверку типа значения и поля, значение должно быть экземпляром 
                    // порверку типа можно исключить для откопмелированого кода
                   
                    var ТипПоля = ((ГруппаОбъектов) ((ГруппаОбъектов) класс[2])[i])[2];
                    if (типЭкземпляраЗначения == ТипПоля)
                    {
                        экземпляр[i]= значение;
                        return new Строка("Готово");
                    }
                    return new Строка("Несовпадение типов поля и значения");

                }
                   
            }
            return new Строка("Нет такого имени поля");

        }
    }
    
}
